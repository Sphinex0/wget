<!DOCTYPE html>
<html lang="en">
<head>
<meta content="text/html; charset=utf-8" http-equiv="content-type"/>
<title>KeBaB: 𝑘-mer based breaking for finding long MEMs</title>
<!--Generated on Mon Jun  9 16:47:56 2025 by LaTeXML (version 0.8.8) http://dlmf.nist.gov/LaTeXML/.-->
<meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" type="text/css"/>
<link href="/static/browse/0.3.4/css/ar5iv.0.7.9.min.css" rel="stylesheet" type="text/css"/>
<link href="/static/browse/0.3.4/css/ar5iv-fonts.0.7.9.min.css" rel="stylesheet" type="text/css"/>
<link href="/static/browse/0.3.4/css/latexml_styles.css" rel="stylesheet" type="text/css"/>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.3.3/html2canvas.min.js"></script>
<script src="/static/browse/0.3.4/js/addons_new.js"></script>
<script src="/static/browse/0.3.4/js/feedbackOverlay.js"></script>
<meta content="Maximal exact matches k-mer filtration Pseudo-MEMs." lang="en" name="keywords"/>
<base href="/html/2502.20338v3/"/></head>
<body>
<nav class="ltx_page_navbar">
<nav class="ltx_TOC">
<ol class="ltx_toclist">
<li class="ltx_tocentry ltx_tocentry_section"><a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S1" title="In KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">1 </span>Introduction</span></a></li>
<li class="ltx_tocentry ltx_tocentry_section"><a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S2" title="In KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">2 </span>MEMs, forward-backward and BML</span></a></li>
<li class="ltx_tocentry ltx_tocentry_section"><a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S3" title="In KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">3 </span><math alttext="k" class="ltx_Math" display="inline"><semantics><mi>k</mi><annotation-xml encoding="MathML-Content"><ci>𝑘</ci></annotation-xml><annotation encoding="application/x-tex">k</annotation><annotation encoding="application/x-llamapun">italic_k</annotation></semantics></math>-mer based breaking into pseudo-MEMs</span></a></li>
<li class="ltx_tocentry ltx_tocentry_section">
<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4" title="In KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">4 </span>Experiments</span></a>
<ol class="ltx_toclist ltx_toclist_section">
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4.SS1" title="In 4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">4.1 </span>MEM-finding</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection">
<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4.SS2" title="In 4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">4.2 </span>Metagenomic Classification</span></a>
<ol class="ltx_toclist ltx_toclist_subsection">
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4.SS2.SSS1" title="In 4.2 Metagenomic Classification ‣ 4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">4.2.1 </span>Acknowledgements</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4.SS2.SSS2" title="In 4.2 Metagenomic Classification ‣ 4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">4.2.2 </span><span class="ltx_ERROR undefined">\discintname</span></span></a></li>
</ol>
</li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_appendix">
<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#Pt0.A1" title="In KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">0.A </span>Optimizations</span></a>
<ol class="ltx_toclist ltx_toclist_appendix">
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#Pt0.A1.SS1" title="In Appendix 0.A Optimizations ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">0.A.1 </span>Bloom filter</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#Pt0.A1.SS2" title="In Appendix 0.A Optimizations ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">0.A.2 </span><math alttext="k" class="ltx_Math" display="inline"><semantics><mi>k</mi><annotation-xml encoding="MathML-Content"><ci>𝑘</ci></annotation-xml><annotation encoding="application/x-tex">k</annotation><annotation encoding="application/x-llamapun">italic_k</annotation></semantics></math>-mer hashing</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#Pt0.A1.SS3" title="In Appendix 0.A Optimizations ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">0.A.3 </span>Latency hiding and parallelization</span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_appendix">
<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#Pt0.A2" title="In KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">0.B </span>Technical details</span></a>
<ol class="ltx_toclist ltx_toclist_appendix">
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#Pt0.A2.SS1" title="In Appendix 0.B Technical details ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">0.B.1 </span>Experiments</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#Pt0.A2.SS2" title="In Appendix 0.B Technical details ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">0.B.2 </span>Output coordinates</span></a></li>
</ol>
</li>
</ol></nav>
</nav>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line"><span class="ltx_note ltx_role_institutetext" id="id1"><sup class="ltx_note_mark">1</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">1</sup><span class="ltx_note_type">institutetext: </span>Johns Hopkins University, Baltimore, USA </span></span></span><span class="ltx_note ltx_role_institutetext" id="id2"><sup class="ltx_note_mark">2</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">2</sup><span class="ltx_note_type">institutetext: </span>Ghent University, Ghent, Belgium </span></span></span><span class="ltx_note ltx_role_institutetext" id="id3"><sup class="ltx_note_mark">3</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">3</sup><span class="ltx_note_type">institutetext: </span>Dalhousie University, Halifax, Canada</span></span></span>
<h1 class="ltx_title ltx_title_document">KeBaB: <math alttext="k" class="ltx_Math" display="inline" id="id1.m1.1"><semantics id="id1.m1.1b"><mi id="id1.m1.1.1" xref="id1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="id1.m1.1c"><ci id="id1.m1.1.1.cmml" xref="id1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="id1.m1.1d">k</annotation><annotation encoding="application/x-llamapun" id="id1.m1.1e">italic_k</annotation></semantics></math>-mer based breaking
<br class="ltx_break"/>for finding long MEMs</h1>
<div class="ltx_authors">
<span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Nathaniel K. Brown
</span><span class="ltx_author_notes">11
<span class="ltx_contact ltx_role_orcid"><a class="ltx_ref" href="https://orcid.org/0000-0002-6201-2301" title="ORCID identifier">0000-0002-6201-2301</a></span>
</span></span>
<span class="ltx_author_before">  </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">
<br class="ltx_break"/>Lore Depuydt
</span><span class="ltx_author_notes">22
<span class="ltx_contact ltx_role_orcid"><a class="ltx_ref" href="https://orcid.org/0000-0001-8517-0479" title="ORCID identifier">0000-0001-8517-0479</a></span>
</span></span>
<span class="ltx_author_before">  </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">
<br class="ltx_break"/>Mohsen Zakeri
</span><span class="ltx_author_notes">11
<span class="ltx_contact ltx_role_orcid"><a class="ltx_ref" href="https://orcid.org/0000-0002-9856-719X" title="ORCID identifier">0000-0002-9856-719X</a></span>
</span></span>
<span class="ltx_author_before">  </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">
<br class="ltx_break"/>Anas Alhadi
</span><span class="ltx_author_notes">33</span></span>
<span class="ltx_author_before">  </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Nour Allam
</span><span class="ltx_author_notes">33</span></span>
<span class="ltx_author_before">  </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Dove Begleiter
</span><span class="ltx_author_notes">33</span></span>
<span class="ltx_author_before">  </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">
<br class="ltx_break"/>Nithin Bharathi Kabilan Karpagavalli
</span><span class="ltx_author_notes">33</span></span>
<span class="ltx_author_before">  </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">
<br class="ltx_break"/>Suchith Sridhar Khajjayam
</span><span class="ltx_author_notes">33</span></span>
<span class="ltx_author_before">  </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Hamza Wahed
</span><span class="ltx_author_notes">33</span></span>
<span class="ltx_author_before">  </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">
<br class="ltx_break"/>Travis Gagie
</span><span class="ltx_author_notes">33
<span class="ltx_contact ltx_role_orcid"><a class="ltx_ref" href="https://orcid.org/0000-0002-1825-0097" title="ORCID identifier">0000-0002-1825-0097</a></span>
</span></span>
<span class="ltx_author_before">  </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">
<br class="ltx_break"/>Ben Langmead
</span><span class="ltx_author_notes">11
<span class="ltx_contact ltx_role_orcid"><a class="ltx_ref" href="https://orcid.org/0000-0003-2437-1976" title="ORCID identifier">0000-0003-2437-1976</a></span>
</span></span>
</div>
<div class="ltx_abstract">
<h6 class="ltx_title ltx_title_abstract">Abstract</h6>
<p class="ltx_p" id="id2.1">Long maximal exact matches (MEMs) are used in many genomics applications such as read classification and sequence alignment. Li’s ropebwt3 finds long MEMs quickly because it can often ignore much of its input. In this paper we show that a fast and space efficient <math alttext="k" class="ltx_Math" display="inline" id="id2.1.m1.1"><semantics id="id2.1.m1.1a"><mi id="id2.1.m1.1.1" xref="id2.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="id2.1.m1.1b"><ci id="id2.1.m1.1.1.cmml" xref="id2.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="id2.1.m1.1c">k</annotation><annotation encoding="application/x-llamapun" id="id2.1.m1.1d">italic_k</annotation></semantics></math>-mer filtration step using a Bloom filter speeds up MEM-finders such as ropebwt3 even further by letting them ignore even more. We also show experimentally that our approach can accelerate metagenomic classification without significantly hurting accuracy.</p>
</div>
<div class="ltx_keywords">
<h6 class="ltx_title ltx_title_keywords">Keywords: </h6>Maximal exact matches k-mer filtration Pseudo-MEMs.
</div>
<section class="ltx_section" id="S1">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">1 </span>Introduction</h2>
<div class="ltx_para" id="S1.p1">
<p class="ltx_p" id="S1.p1.1">A challenge for today’s string-matching algorithms is to compute exact matches with respect to an index over a large, repetitive text. This is a pressing problem in computational genomics, where databases of reference genomes and pangenomes are growing very rapidly.
One highly practical full-text indexing method for pangenomes is <span class="ltx_text ltx_font_typewriter" id="S1.p1.1.1">ropebwt3</span> <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib10" title="">10</a>]</cite>, which indexes using a run-length compressed form of the Burrows-Wheeler Transform of the text. Its strategy for querying the index involves skipping along the query in the style of Boyer-Moore pattern matching <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib3" title="">3</a>]</cite>, an idea that was first connected to BWT queries by Gagie <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib8" title="">8</a>]</cite>.
Internally, <span class="ltx_text ltx_font_typewriter" id="S1.p1.1.2">ropebwt3</span> uses a bidirectional FM index together with a forward-backward matching algorithm for finding long maximal exact matches (MEMs).</p>
</div>
<div class="ltx_para" id="S1.p2">
<p class="ltx_p" id="S1.p2.5">In this paper we propose a fast <math alttext="k" class="ltx_Math" display="inline" id="S1.p2.1.m1.1"><semantics id="S1.p2.1.m1.1a"><mi id="S1.p2.1.m1.1.1" xref="S1.p2.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S1.p2.1.m1.1b"><ci id="S1.p2.1.m1.1.1.cmml" xref="S1.p2.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.1.m1.1c">k</annotation><annotation encoding="application/x-llamapun" id="S1.p2.1.m1.1d">italic_k</annotation></semantics></math>-mer filtration strategy using a Bloom filter that allows for more skipping and speeds <span class="ltx_text ltx_font_typewriter" id="S1.p2.5.1">ropebwt3</span> up substantially. We call our strategy KeBaB for “<math alttext="k" class="ltx_Math" display="inline" id="S1.p2.2.m2.1"><semantics id="S1.p2.2.m2.1a"><mi id="S1.p2.2.m2.1.1" xref="S1.p2.2.m2.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S1.p2.2.m2.1b"><ci id="S1.p2.2.m2.1.1.cmml" xref="S1.p2.2.m2.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.2.m2.1c">k</annotation><annotation encoding="application/x-llamapun" id="S1.p2.2.m2.1d">italic_k</annotation></semantics></math>-mer based breaking”.
In Section <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S2" title="2 MEMs, forward-backward and BML ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">2</span></a> we briefly review MEM-finding. In Section <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S3" title="3 𝑘-mer based breaking into pseudo-MEMs ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">3</span></a>, we describe how to break a pattern into substrings we call pseudo-MEMs that are guaranteed to contain all sufficiently long MEMs of the pattern with respect to an indexed text. If we are interested only in the <math alttext="t" class="ltx_Math" display="inline" id="S1.p2.3.m3.1"><semantics id="S1.p2.3.m3.1a"><mi id="S1.p2.3.m3.1.1" xref="S1.p2.3.m3.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S1.p2.3.m3.1b"><ci id="S1.p2.3.m3.1.1.cmml" xref="S1.p2.3.m3.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.3.m3.1c">t</annotation><annotation encoding="application/x-llamapun" id="S1.p2.3.m3.1d">italic_t</annotation></semantics></math> longest MEMs, then we can search in the pseudo-MEMs in non-increasing order by length and stop when we have found <math alttext="t" class="ltx_Math" display="inline" id="S1.p2.4.m4.1"><semantics id="S1.p2.4.m4.1a"><mi id="S1.p2.4.m4.1.1" xref="S1.p2.4.m4.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S1.p2.4.m4.1b"><ci id="S1.p2.4.m4.1.1.cmml" xref="S1.p2.4.m4.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.4.m4.1c">t</annotation><annotation encoding="application/x-llamapun" id="S1.p2.4.m4.1d">italic_t</annotation></semantics></math> MEMs at least as long as the next pseudo-MEM. This should require modifying <span class="ltx_text ltx_font_typewriter" id="S1.p2.5.2">ropebwt3</span> but our experiments in Section <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4" title="4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">4</span></a> indicate that simply searching in the <math alttext="t" class="ltx_Math" display="inline" id="S1.p2.5.m5.1"><semantics id="S1.p2.5.m5.1a"><mi id="S1.p2.5.m5.1.1" xref="S1.p2.5.m5.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S1.p2.5.m5.1b"><ci id="S1.p2.5.m5.1.1.cmml" xref="S1.p2.5.m5.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.5.m5.1c">t</annotation><annotation encoding="application/x-llamapun" id="S1.p2.5.m5.1d">italic_t</annotation></semantics></math> longest pseudo-MEMs and discarding the rest does not significantly affect downstream results — even compared to using all the long MEMs. Figure <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S1.F1" title="Figure 1 ‣ 1 Introduction ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">1</span></a> shows an example of how to use KeBaB to find pseudo-MEMs.</p>
</div>
<figure class="ltx_figure" id="S1.F1"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="289" id="S1.F1.g1" src="x1.png" width="747"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 1: </span>An example of how to use KeBaB to find pseudo-MEMs.</figcaption>
</figure>
</section>
<section class="ltx_section" id="S2">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">2 </span>MEMs, forward-backward and BML</h2>
<div class="ltx_para" id="S2.p1">
<p class="ltx_p" id="S2.p1.3">A <span class="ltx_text ltx_font_italic" id="S2.p1.3.1">maximal exact match</span> (MEM) — also called super-maximal exact matches (SMEMs) — of a pattern <math alttext="P[0..m-1]" class="ltx_math_unparsed" display="inline" id="S2.p1.1.m1.1"><semantics id="S2.p1.1.m1.1a"><mrow id="S2.p1.1.m1.1b"><mi id="S2.p1.1.m1.1.1">P</mi><mrow id="S2.p1.1.m1.1.2"><mo id="S2.p1.1.m1.1.2.1" stretchy="false">[</mo><mn id="S2.p1.1.m1.1.2.2">0</mn><mo id="S2.p1.1.m1.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p1.1.m1.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S2.p1.1.m1.1.2.5">m</mi><mo id="S2.p1.1.m1.1.2.6">−</mo><mn id="S2.p1.1.m1.1.2.7">1</mn><mo id="S2.p1.1.m1.1.2.8" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p1.1.m1.1c">P[0..m-1]</annotation><annotation encoding="application/x-llamapun" id="S2.p1.1.m1.1d">italic_P [ 0 . . italic_m - 1 ]</annotation></semantics></math> with respect to a text <math alttext="T[0..n-1]" class="ltx_math_unparsed" display="inline" id="S2.p1.2.m2.1"><semantics id="S2.p1.2.m2.1a"><mrow id="S2.p1.2.m2.1b"><mi id="S2.p1.2.m2.1.1">T</mi><mrow id="S2.p1.2.m2.1.2"><mo id="S2.p1.2.m2.1.2.1" stretchy="false">[</mo><mn id="S2.p1.2.m2.1.2.2">0</mn><mo id="S2.p1.2.m2.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p1.2.m2.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S2.p1.2.m2.1.2.5">n</mi><mo id="S2.p1.2.m2.1.2.6">−</mo><mn id="S2.p1.2.m2.1.2.7">1</mn><mo id="S2.p1.2.m2.1.2.8" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p1.2.m2.1c">T[0..n-1]</annotation><annotation encoding="application/x-llamapun" id="S2.p1.2.m2.1d">italic_T [ 0 . . italic_n - 1 ]</annotation></semantics></math> is a substring <math alttext="P[i..j]" class="ltx_math_unparsed" display="inline" id="S2.p1.3.m3.1"><semantics id="S2.p1.3.m3.1a"><mrow id="S2.p1.3.m3.1b"><mi id="S2.p1.3.m3.1.1">P</mi><mrow id="S2.p1.3.m3.1.2"><mo id="S2.p1.3.m3.1.2.1" stretchy="false">[</mo><mi id="S2.p1.3.m3.1.2.2">i</mi><mo id="S2.p1.3.m3.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p1.3.m3.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S2.p1.3.m3.1.2.5">j</mi><mo id="S2.p1.3.m3.1.2.6" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p1.3.m3.1c">P[i..j]</annotation><annotation encoding="application/x-llamapun" id="S2.p1.3.m3.1d">italic_P [ italic_i . . italic_j ]</annotation></semantics></math> such that</p>
<ul class="ltx_itemize" id="S2.I1">
<li class="ltx_item" id="S2.I1.i1" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S2.I1.i1.p1">
<p class="ltx_p" id="S2.I1.i1.p1.2"><math alttext="P[i..j]" class="ltx_math_unparsed" display="inline" id="S2.I1.i1.p1.1.m1.1"><semantics id="S2.I1.i1.p1.1.m1.1a"><mrow id="S2.I1.i1.p1.1.m1.1b"><mi id="S2.I1.i1.p1.1.m1.1.1">P</mi><mrow id="S2.I1.i1.p1.1.m1.1.2"><mo id="S2.I1.i1.p1.1.m1.1.2.1" stretchy="false">[</mo><mi id="S2.I1.i1.p1.1.m1.1.2.2">i</mi><mo id="S2.I1.i1.p1.1.m1.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.I1.i1.p1.1.m1.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S2.I1.i1.p1.1.m1.1.2.5">j</mi><mo id="S2.I1.i1.p1.1.m1.1.2.6" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.I1.i1.p1.1.m1.1c">P[i..j]</annotation><annotation encoding="application/x-llamapun" id="S2.I1.i1.p1.1.m1.1d">italic_P [ italic_i . . italic_j ]</annotation></semantics></math> occurs in <math alttext="T" class="ltx_Math" display="inline" id="S2.I1.i1.p1.2.m2.1"><semantics id="S2.I1.i1.p1.2.m2.1a"><mi id="S2.I1.i1.p1.2.m2.1.1" xref="S2.I1.i1.p1.2.m2.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S2.I1.i1.p1.2.m2.1b"><ci id="S2.I1.i1.p1.2.m2.1.1.cmml" xref="S2.I1.i1.p1.2.m2.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.I1.i1.p1.2.m2.1c">T</annotation><annotation encoding="application/x-llamapun" id="S2.I1.i1.p1.2.m2.1d">italic_T</annotation></semantics></math>,</p>
</div>
</li>
<li class="ltx_item" id="S2.I1.i2" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S2.I1.i2.p1">
<p class="ltx_p" id="S2.I1.i2.p1.3"><math alttext="i=0" class="ltx_Math" display="inline" id="S2.I1.i2.p1.1.m1.1"><semantics id="S2.I1.i2.p1.1.m1.1a"><mrow id="S2.I1.i2.p1.1.m1.1.1" xref="S2.I1.i2.p1.1.m1.1.1.cmml"><mi id="S2.I1.i2.p1.1.m1.1.1.2" xref="S2.I1.i2.p1.1.m1.1.1.2.cmml">i</mi><mo id="S2.I1.i2.p1.1.m1.1.1.1" xref="S2.I1.i2.p1.1.m1.1.1.1.cmml">=</mo><mn id="S2.I1.i2.p1.1.m1.1.1.3" xref="S2.I1.i2.p1.1.m1.1.1.3.cmml">0</mn></mrow><annotation-xml encoding="MathML-Content" id="S2.I1.i2.p1.1.m1.1b"><apply id="S2.I1.i2.p1.1.m1.1.1.cmml" xref="S2.I1.i2.p1.1.m1.1.1"><eq id="S2.I1.i2.p1.1.m1.1.1.1.cmml" xref="S2.I1.i2.p1.1.m1.1.1.1"></eq><ci id="S2.I1.i2.p1.1.m1.1.1.2.cmml" xref="S2.I1.i2.p1.1.m1.1.1.2">𝑖</ci><cn id="S2.I1.i2.p1.1.m1.1.1.3.cmml" type="integer" xref="S2.I1.i2.p1.1.m1.1.1.3">0</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.I1.i2.p1.1.m1.1c">i=0</annotation><annotation encoding="application/x-llamapun" id="S2.I1.i2.p1.1.m1.1d">italic_i = 0</annotation></semantics></math> or <math alttext="P[i-1..j]" class="ltx_math_unparsed" display="inline" id="S2.I1.i2.p1.2.m2.1"><semantics id="S2.I1.i2.p1.2.m2.1a"><mrow id="S2.I1.i2.p1.2.m2.1b"><mi id="S2.I1.i2.p1.2.m2.1.1">P</mi><mrow id="S2.I1.i2.p1.2.m2.1.2"><mo id="S2.I1.i2.p1.2.m2.1.2.1" stretchy="false">[</mo><mi id="S2.I1.i2.p1.2.m2.1.2.2">i</mi><mo id="S2.I1.i2.p1.2.m2.1.2.3">−</mo><mn id="S2.I1.i2.p1.2.m2.1.2.4">1</mn><mo id="S2.I1.i2.p1.2.m2.1.2.5" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.I1.i2.p1.2.m2.1.2.6" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S2.I1.i2.p1.2.m2.1.2.7">j</mi><mo id="S2.I1.i2.p1.2.m2.1.2.8" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.I1.i2.p1.2.m2.1c">P[i-1..j]</annotation><annotation encoding="application/x-llamapun" id="S2.I1.i2.p1.2.m2.1d">italic_P [ italic_i - 1 . . italic_j ]</annotation></semantics></math> does not occur in <math alttext="T" class="ltx_Math" display="inline" id="S2.I1.i2.p1.3.m3.1"><semantics id="S2.I1.i2.p1.3.m3.1a"><mi id="S2.I1.i2.p1.3.m3.1.1" xref="S2.I1.i2.p1.3.m3.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S2.I1.i2.p1.3.m3.1b"><ci id="S2.I1.i2.p1.3.m3.1.1.cmml" xref="S2.I1.i2.p1.3.m3.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.I1.i2.p1.3.m3.1c">T</annotation><annotation encoding="application/x-llamapun" id="S2.I1.i2.p1.3.m3.1d">italic_T</annotation></semantics></math>,</p>
</div>
</li>
<li class="ltx_item" id="S2.I1.i3" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S2.I1.i3.p1">
<p class="ltx_p" id="S2.I1.i3.p1.3"><math alttext="j=m-1" class="ltx_Math" display="inline" id="S2.I1.i3.p1.1.m1.1"><semantics id="S2.I1.i3.p1.1.m1.1a"><mrow id="S2.I1.i3.p1.1.m1.1.1" xref="S2.I1.i3.p1.1.m1.1.1.cmml"><mi id="S2.I1.i3.p1.1.m1.1.1.2" xref="S2.I1.i3.p1.1.m1.1.1.2.cmml">j</mi><mo id="S2.I1.i3.p1.1.m1.1.1.1" xref="S2.I1.i3.p1.1.m1.1.1.1.cmml">=</mo><mrow id="S2.I1.i3.p1.1.m1.1.1.3" xref="S2.I1.i3.p1.1.m1.1.1.3.cmml"><mi id="S2.I1.i3.p1.1.m1.1.1.3.2" xref="S2.I1.i3.p1.1.m1.1.1.3.2.cmml">m</mi><mo id="S2.I1.i3.p1.1.m1.1.1.3.1" xref="S2.I1.i3.p1.1.m1.1.1.3.1.cmml">−</mo><mn id="S2.I1.i3.p1.1.m1.1.1.3.3" xref="S2.I1.i3.p1.1.m1.1.1.3.3.cmml">1</mn></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.I1.i3.p1.1.m1.1b"><apply id="S2.I1.i3.p1.1.m1.1.1.cmml" xref="S2.I1.i3.p1.1.m1.1.1"><eq id="S2.I1.i3.p1.1.m1.1.1.1.cmml" xref="S2.I1.i3.p1.1.m1.1.1.1"></eq><ci id="S2.I1.i3.p1.1.m1.1.1.2.cmml" xref="S2.I1.i3.p1.1.m1.1.1.2">𝑗</ci><apply id="S2.I1.i3.p1.1.m1.1.1.3.cmml" xref="S2.I1.i3.p1.1.m1.1.1.3"><minus id="S2.I1.i3.p1.1.m1.1.1.3.1.cmml" xref="S2.I1.i3.p1.1.m1.1.1.3.1"></minus><ci id="S2.I1.i3.p1.1.m1.1.1.3.2.cmml" xref="S2.I1.i3.p1.1.m1.1.1.3.2">𝑚</ci><cn id="S2.I1.i3.p1.1.m1.1.1.3.3.cmml" type="integer" xref="S2.I1.i3.p1.1.m1.1.1.3.3">1</cn></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.I1.i3.p1.1.m1.1c">j=m-1</annotation><annotation encoding="application/x-llamapun" id="S2.I1.i3.p1.1.m1.1d">italic_j = italic_m - 1</annotation></semantics></math> or <math alttext="P[i..j+1]" class="ltx_math_unparsed" display="inline" id="S2.I1.i3.p1.2.m2.1"><semantics id="S2.I1.i3.p1.2.m2.1a"><mrow id="S2.I1.i3.p1.2.m2.1b"><mi id="S2.I1.i3.p1.2.m2.1.1">P</mi><mrow id="S2.I1.i3.p1.2.m2.1.2"><mo id="S2.I1.i3.p1.2.m2.1.2.1" stretchy="false">[</mo><mi id="S2.I1.i3.p1.2.m2.1.2.2">i</mi><mo id="S2.I1.i3.p1.2.m2.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.I1.i3.p1.2.m2.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S2.I1.i3.p1.2.m2.1.2.5">j</mi><mo id="S2.I1.i3.p1.2.m2.1.2.6">+</mo><mn id="S2.I1.i3.p1.2.m2.1.2.7">1</mn><mo id="S2.I1.i3.p1.2.m2.1.2.8" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.I1.i3.p1.2.m2.1c">P[i..j+1]</annotation><annotation encoding="application/x-llamapun" id="S2.I1.i3.p1.2.m2.1d">italic_P [ italic_i . . italic_j + 1 ]</annotation></semantics></math> does not occur in <math alttext="T" class="ltx_Math" display="inline" id="S2.I1.i3.p1.3.m3.1"><semantics id="S2.I1.i3.p1.3.m3.1a"><mi id="S2.I1.i3.p1.3.m3.1.1" xref="S2.I1.i3.p1.3.m3.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S2.I1.i3.p1.3.m3.1b"><ci id="S2.I1.i3.p1.3.m3.1.1.cmml" xref="S2.I1.i3.p1.3.m3.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.I1.i3.p1.3.m3.1c">T</annotation><annotation encoding="application/x-llamapun" id="S2.I1.i3.p1.3.m3.1d">italic_T</annotation></semantics></math>.</p>
</div>
</li>
</ul>
<p class="ltx_p" id="S2.p1.4">Finding MEMs is an important step in many bioinformatics pipelines, such as aligning long and error-prone DNA reads to large pangenomic references.</p>
</div>
<div class="ltx_para" id="S2.p2">
<p class="ltx_p" id="S2.p2.18">For Li’s <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib9" title="">9</a>]</cite> popular forward-backward MEM-finding algorithm, we keep FM-indexes <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib6" title="">6</a>]</cite> of <math alttext="T" class="ltx_Math" display="inline" id="S2.p2.1.m1.1"><semantics id="S2.p2.1.m1.1a"><mi id="S2.p2.1.m1.1.1" xref="S2.p2.1.m1.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S2.p2.1.m1.1b"><ci id="S2.p2.1.m1.1.1.cmml" xref="S2.p2.1.m1.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.1.m1.1c">T</annotation><annotation encoding="application/x-llamapun" id="S2.p2.1.m1.1d">italic_T</annotation></semantics></math> and its reverse <math alttext="T^{\mathrm{rev}}" class="ltx_Math" display="inline" id="S2.p2.2.m2.1"><semantics id="S2.p2.2.m2.1a"><msup id="S2.p2.2.m2.1.1" xref="S2.p2.2.m2.1.1.cmml"><mi id="S2.p2.2.m2.1.1.2" xref="S2.p2.2.m2.1.1.2.cmml">T</mi><mi id="S2.p2.2.m2.1.1.3" xref="S2.p2.2.m2.1.1.3.cmml">rev</mi></msup><annotation-xml encoding="MathML-Content" id="S2.p2.2.m2.1b"><apply id="S2.p2.2.m2.1.1.cmml" xref="S2.p2.2.m2.1.1"><csymbol cd="ambiguous" id="S2.p2.2.m2.1.1.1.cmml" xref="S2.p2.2.m2.1.1">superscript</csymbol><ci id="S2.p2.2.m2.1.1.2.cmml" xref="S2.p2.2.m2.1.1.2">𝑇</ci><ci id="S2.p2.2.m2.1.1.3.cmml" xref="S2.p2.2.m2.1.1.3">rev</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.2.m2.1c">T^{\mathrm{rev}}</annotation><annotation encoding="application/x-llamapun" id="S2.p2.2.m2.1d">italic_T start_POSTSUPERSCRIPT roman_rev end_POSTSUPERSCRIPT</annotation></semantics></math>.
Assuming all the characters in <math alttext="P" class="ltx_Math" display="inline" id="S2.p2.3.m3.1"><semantics id="S2.p2.3.m3.1a"><mi id="S2.p2.3.m3.1.1" xref="S2.p2.3.m3.1.1.cmml">P</mi><annotation-xml encoding="MathML-Content" id="S2.p2.3.m3.1b"><ci id="S2.p2.3.m3.1.1.cmml" xref="S2.p2.3.m3.1.1">𝑃</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.3.m3.1c">P</annotation><annotation encoding="application/x-llamapun" id="S2.p2.3.m3.1d">italic_P</annotation></semantics></math> occur in <math alttext="T" class="ltx_Math" display="inline" id="S2.p2.4.m4.1"><semantics id="S2.p2.4.m4.1a"><mi id="S2.p2.4.m4.1.1" xref="S2.p2.4.m4.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S2.p2.4.m4.1b"><ci id="S2.p2.4.m4.1.1.cmml" xref="S2.p2.4.m4.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.4.m4.1c">T</annotation><annotation encoding="application/x-llamapun" id="S2.p2.4.m4.1d">italic_T</annotation></semantics></math>, the leftmost MEM starts at <math alttext="P[0]" class="ltx_Math" display="inline" id="S2.p2.5.m5.1"><semantics id="S2.p2.5.m5.1a"><mrow id="S2.p2.5.m5.1.2" xref="S2.p2.5.m5.1.2.cmml"><mi id="S2.p2.5.m5.1.2.2" xref="S2.p2.5.m5.1.2.2.cmml">P</mi><mo id="S2.p2.5.m5.1.2.1" xref="S2.p2.5.m5.1.2.1.cmml">⁢</mo><mrow id="S2.p2.5.m5.1.2.3.2" xref="S2.p2.5.m5.1.2.3.1.cmml"><mo id="S2.p2.5.m5.1.2.3.2.1" stretchy="false" xref="S2.p2.5.m5.1.2.3.1.1.cmml">[</mo><mn id="S2.p2.5.m5.1.1" xref="S2.p2.5.m5.1.1.cmml">0</mn><mo id="S2.p2.5.m5.1.2.3.2.2" stretchy="false" xref="S2.p2.5.m5.1.2.3.1.1.cmml">]</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.5.m5.1b"><apply id="S2.p2.5.m5.1.2.cmml" xref="S2.p2.5.m5.1.2"><times id="S2.p2.5.m5.1.2.1.cmml" xref="S2.p2.5.m5.1.2.1"></times><ci id="S2.p2.5.m5.1.2.2.cmml" xref="S2.p2.5.m5.1.2.2">𝑃</ci><apply id="S2.p2.5.m5.1.2.3.1.cmml" xref="S2.p2.5.m5.1.2.3.2"><csymbol cd="latexml" id="S2.p2.5.m5.1.2.3.1.1.cmml" xref="S2.p2.5.m5.1.2.3.2.1">delimited-[]</csymbol><cn id="S2.p2.5.m5.1.1.cmml" type="integer" xref="S2.p2.5.m5.1.1">0</cn></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.5.m5.1c">P[0]</annotation><annotation encoding="application/x-llamapun" id="S2.p2.5.m5.1d">italic_P [ 0 ]</annotation></semantics></math>. We can therefore find the leftmost MEM <math alttext="P[0..e_{1}]" class="ltx_math_unparsed" display="inline" id="S2.p2.6.m6.1"><semantics id="S2.p2.6.m6.1a"><mrow id="S2.p2.6.m6.1b"><mi id="S2.p2.6.m6.1.1">P</mi><mrow id="S2.p2.6.m6.1.2"><mo id="S2.p2.6.m6.1.2.1" stretchy="false">[</mo><mn id="S2.p2.6.m6.1.2.2">0</mn><mo id="S2.p2.6.m6.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p2.6.m6.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><msub id="S2.p2.6.m6.1.2.5"><mi id="S2.p2.6.m6.1.2.5.2">e</mi><mn id="S2.p2.6.m6.1.2.5.3">1</mn></msub><mo id="S2.p2.6.m6.1.2.6" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p2.6.m6.1c">P[0..e_{1}]</annotation><annotation encoding="application/x-llamapun" id="S2.p2.6.m6.1d">italic_P [ 0 . . italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ]</annotation></semantics></math> by searching for <math alttext="P^{\mathrm{rev}}" class="ltx_Math" display="inline" id="S2.p2.7.m7.1"><semantics id="S2.p2.7.m7.1a"><msup id="S2.p2.7.m7.1.1" xref="S2.p2.7.m7.1.1.cmml"><mi id="S2.p2.7.m7.1.1.2" xref="S2.p2.7.m7.1.1.2.cmml">P</mi><mi id="S2.p2.7.m7.1.1.3" xref="S2.p2.7.m7.1.1.3.cmml">rev</mi></msup><annotation-xml encoding="MathML-Content" id="S2.p2.7.m7.1b"><apply id="S2.p2.7.m7.1.1.cmml" xref="S2.p2.7.m7.1.1"><csymbol cd="ambiguous" id="S2.p2.7.m7.1.1.1.cmml" xref="S2.p2.7.m7.1.1">superscript</csymbol><ci id="S2.p2.7.m7.1.1.2.cmml" xref="S2.p2.7.m7.1.1.2">𝑃</ci><ci id="S2.p2.7.m7.1.1.3.cmml" xref="S2.p2.7.m7.1.1.3">rev</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.7.m7.1c">P^{\mathrm{rev}}</annotation><annotation encoding="application/x-llamapun" id="S2.p2.7.m7.1d">italic_P start_POSTSUPERSCRIPT roman_rev end_POSTSUPERSCRIPT</annotation></semantics></math> in the index for <math alttext="T^{\mathrm{rev}}" class="ltx_Math" display="inline" id="S2.p2.8.m8.1"><semantics id="S2.p2.8.m8.1a"><msup id="S2.p2.8.m8.1.1" xref="S2.p2.8.m8.1.1.cmml"><mi id="S2.p2.8.m8.1.1.2" xref="S2.p2.8.m8.1.1.2.cmml">T</mi><mi id="S2.p2.8.m8.1.1.3" xref="S2.p2.8.m8.1.1.3.cmml">rev</mi></msup><annotation-xml encoding="MathML-Content" id="S2.p2.8.m8.1b"><apply id="S2.p2.8.m8.1.1.cmml" xref="S2.p2.8.m8.1.1"><csymbol cd="ambiguous" id="S2.p2.8.m8.1.1.1.cmml" xref="S2.p2.8.m8.1.1">superscript</csymbol><ci id="S2.p2.8.m8.1.1.2.cmml" xref="S2.p2.8.m8.1.1.2">𝑇</ci><ci id="S2.p2.8.m8.1.1.3.cmml" xref="S2.p2.8.m8.1.1.3">rev</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.8.m8.1c">T^{\mathrm{rev}}</annotation><annotation encoding="application/x-llamapun" id="S2.p2.8.m8.1d">italic_T start_POSTSUPERSCRIPT roman_rev end_POSTSUPERSCRIPT</annotation></semantics></math>.
If <math alttext="e_{1}&lt;m-1" class="ltx_Math" display="inline" id="S2.p2.9.m9.1"><semantics id="S2.p2.9.m9.1a"><mrow id="S2.p2.9.m9.1.1" xref="S2.p2.9.m9.1.1.cmml"><msub id="S2.p2.9.m9.1.1.2" xref="S2.p2.9.m9.1.1.2.cmml"><mi id="S2.p2.9.m9.1.1.2.2" xref="S2.p2.9.m9.1.1.2.2.cmml">e</mi><mn id="S2.p2.9.m9.1.1.2.3" xref="S2.p2.9.m9.1.1.2.3.cmml">1</mn></msub><mo id="S2.p2.9.m9.1.1.1" xref="S2.p2.9.m9.1.1.1.cmml">&lt;</mo><mrow id="S2.p2.9.m9.1.1.3" xref="S2.p2.9.m9.1.1.3.cmml"><mi id="S2.p2.9.m9.1.1.3.2" xref="S2.p2.9.m9.1.1.3.2.cmml">m</mi><mo id="S2.p2.9.m9.1.1.3.1" xref="S2.p2.9.m9.1.1.3.1.cmml">−</mo><mn id="S2.p2.9.m9.1.1.3.3" xref="S2.p2.9.m9.1.1.3.3.cmml">1</mn></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.9.m9.1b"><apply id="S2.p2.9.m9.1.1.cmml" xref="S2.p2.9.m9.1.1"><lt id="S2.p2.9.m9.1.1.1.cmml" xref="S2.p2.9.m9.1.1.1"></lt><apply id="S2.p2.9.m9.1.1.2.cmml" xref="S2.p2.9.m9.1.1.2"><csymbol cd="ambiguous" id="S2.p2.9.m9.1.1.2.1.cmml" xref="S2.p2.9.m9.1.1.2">subscript</csymbol><ci id="S2.p2.9.m9.1.1.2.2.cmml" xref="S2.p2.9.m9.1.1.2.2">𝑒</ci><cn id="S2.p2.9.m9.1.1.2.3.cmml" type="integer" xref="S2.p2.9.m9.1.1.2.3">1</cn></apply><apply id="S2.p2.9.m9.1.1.3.cmml" xref="S2.p2.9.m9.1.1.3"><minus id="S2.p2.9.m9.1.1.3.1.cmml" xref="S2.p2.9.m9.1.1.3.1"></minus><ci id="S2.p2.9.m9.1.1.3.2.cmml" xref="S2.p2.9.m9.1.1.3.2">𝑚</ci><cn id="S2.p2.9.m9.1.1.3.3.cmml" type="integer" xref="S2.p2.9.m9.1.1.3.3">1</cn></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.9.m9.1c">e_{1}&lt;m-1</annotation><annotation encoding="application/x-llamapun" id="S2.p2.9.m9.1d">italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT &lt; italic_m - 1</annotation></semantics></math> then the second MEM <math alttext="P[s_{2}..e_{2}]" class="ltx_math_unparsed" display="inline" id="S2.p2.10.m10.1"><semantics id="S2.p2.10.m10.1a"><mrow id="S2.p2.10.m10.1b"><mi id="S2.p2.10.m10.1.1">P</mi><mrow id="S2.p2.10.m10.1.2"><mo id="S2.p2.10.m10.1.2.1" stretchy="false">[</mo><msub id="S2.p2.10.m10.1.2.2"><mi id="S2.p2.10.m10.1.2.2.2">s</mi><mn id="S2.p2.10.m10.1.2.2.3">2</mn></msub><mo id="S2.p2.10.m10.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p2.10.m10.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><msub id="S2.p2.10.m10.1.2.5"><mi id="S2.p2.10.m10.1.2.5.2">e</mi><mn id="S2.p2.10.m10.1.2.5.3">2</mn></msub><mo id="S2.p2.10.m10.1.2.6" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p2.10.m10.1c">P[s_{2}..e_{2}]</annotation><annotation encoding="application/x-llamapun" id="S2.p2.10.m10.1d">italic_P [ italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT . . italic_e start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ]</annotation></semantics></math> from the left in <math alttext="P" class="ltx_Math" display="inline" id="S2.p2.11.m11.1"><semantics id="S2.p2.11.m11.1a"><mi id="S2.p2.11.m11.1.1" xref="S2.p2.11.m11.1.1.cmml">P</mi><annotation-xml encoding="MathML-Content" id="S2.p2.11.m11.1b"><ci id="S2.p2.11.m11.1.1.cmml" xref="S2.p2.11.m11.1.1">𝑃</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.11.m11.1c">P</annotation><annotation encoding="application/x-llamapun" id="S2.p2.11.m11.1d">italic_P</annotation></semantics></math> includes <math alttext="P[e_{1}+1]" class="ltx_Math" display="inline" id="S2.p2.12.m12.1"><semantics id="S2.p2.12.m12.1a"><mrow id="S2.p2.12.m12.1.1" xref="S2.p2.12.m12.1.1.cmml"><mi id="S2.p2.12.m12.1.1.3" xref="S2.p2.12.m12.1.1.3.cmml">P</mi><mo id="S2.p2.12.m12.1.1.2" xref="S2.p2.12.m12.1.1.2.cmml">⁢</mo><mrow id="S2.p2.12.m12.1.1.1.1" xref="S2.p2.12.m12.1.1.1.2.cmml"><mo id="S2.p2.12.m12.1.1.1.1.2" stretchy="false" xref="S2.p2.12.m12.1.1.1.2.1.cmml">[</mo><mrow id="S2.p2.12.m12.1.1.1.1.1" xref="S2.p2.12.m12.1.1.1.1.1.cmml"><msub id="S2.p2.12.m12.1.1.1.1.1.2" xref="S2.p2.12.m12.1.1.1.1.1.2.cmml"><mi id="S2.p2.12.m12.1.1.1.1.1.2.2" xref="S2.p2.12.m12.1.1.1.1.1.2.2.cmml">e</mi><mn id="S2.p2.12.m12.1.1.1.1.1.2.3" xref="S2.p2.12.m12.1.1.1.1.1.2.3.cmml">1</mn></msub><mo id="S2.p2.12.m12.1.1.1.1.1.1" xref="S2.p2.12.m12.1.1.1.1.1.1.cmml">+</mo><mn id="S2.p2.12.m12.1.1.1.1.1.3" xref="S2.p2.12.m12.1.1.1.1.1.3.cmml">1</mn></mrow><mo id="S2.p2.12.m12.1.1.1.1.3" stretchy="false" xref="S2.p2.12.m12.1.1.1.2.1.cmml">]</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.12.m12.1b"><apply id="S2.p2.12.m12.1.1.cmml" xref="S2.p2.12.m12.1.1"><times id="S2.p2.12.m12.1.1.2.cmml" xref="S2.p2.12.m12.1.1.2"></times><ci id="S2.p2.12.m12.1.1.3.cmml" xref="S2.p2.12.m12.1.1.3">𝑃</ci><apply id="S2.p2.12.m12.1.1.1.2.cmml" xref="S2.p2.12.m12.1.1.1.1"><csymbol cd="latexml" id="S2.p2.12.m12.1.1.1.2.1.cmml" xref="S2.p2.12.m12.1.1.1.1.2">delimited-[]</csymbol><apply id="S2.p2.12.m12.1.1.1.1.1.cmml" xref="S2.p2.12.m12.1.1.1.1.1"><plus id="S2.p2.12.m12.1.1.1.1.1.1.cmml" xref="S2.p2.12.m12.1.1.1.1.1.1"></plus><apply id="S2.p2.12.m12.1.1.1.1.1.2.cmml" xref="S2.p2.12.m12.1.1.1.1.1.2"><csymbol cd="ambiguous" id="S2.p2.12.m12.1.1.1.1.1.2.1.cmml" xref="S2.p2.12.m12.1.1.1.1.1.2">subscript</csymbol><ci id="S2.p2.12.m12.1.1.1.1.1.2.2.cmml" xref="S2.p2.12.m12.1.1.1.1.1.2.2">𝑒</ci><cn id="S2.p2.12.m12.1.1.1.1.1.2.3.cmml" type="integer" xref="S2.p2.12.m12.1.1.1.1.1.2.3">1</cn></apply><cn id="S2.p2.12.m12.1.1.1.1.1.3.cmml" type="integer" xref="S2.p2.12.m12.1.1.1.1.1.3">1</cn></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.12.m12.1c">P[e_{1}+1]</annotation><annotation encoding="application/x-llamapun" id="S2.p2.12.m12.1d">italic_P [ italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + 1 ]</annotation></semantics></math>. By definition, no MEM includes <math alttext="P[s_{2}-1..e_{1}+1]" class="ltx_math_unparsed" display="inline" id="S2.p2.13.m13.1"><semantics id="S2.p2.13.m13.1a"><mrow id="S2.p2.13.m13.1b"><mi id="S2.p2.13.m13.1.1">P</mi><mrow id="S2.p2.13.m13.1.2"><mo id="S2.p2.13.m13.1.2.1" stretchy="false">[</mo><msub id="S2.p2.13.m13.1.2.2"><mi id="S2.p2.13.m13.1.2.2.2">s</mi><mn id="S2.p2.13.m13.1.2.2.3">2</mn></msub><mo id="S2.p2.13.m13.1.2.3">−</mo><mn id="S2.p2.13.m13.1.2.4">1</mn><mo id="S2.p2.13.m13.1.2.5" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p2.13.m13.1.2.6" lspace="0.0835em" rspace="0.167em">.</mo><msub id="S2.p2.13.m13.1.2.7"><mi id="S2.p2.13.m13.1.2.7.2">e</mi><mn id="S2.p2.13.m13.1.2.7.3">1</mn></msub><mo id="S2.p2.13.m13.1.2.8">+</mo><mn id="S2.p2.13.m13.1.2.9">1</mn><mo id="S2.p2.13.m13.1.2.10" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p2.13.m13.1c">P[s_{2}-1..e_{1}+1]</annotation><annotation encoding="application/x-llamapun" id="S2.p2.13.m13.1d">italic_P [ italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - 1 . . italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + 1 ]</annotation></semantics></math>, so we can find <math alttext="s_{2}" class="ltx_Math" display="inline" id="S2.p2.14.m14.1"><semantics id="S2.p2.14.m14.1a"><msub id="S2.p2.14.m14.1.1" xref="S2.p2.14.m14.1.1.cmml"><mi id="S2.p2.14.m14.1.1.2" xref="S2.p2.14.m14.1.1.2.cmml">s</mi><mn id="S2.p2.14.m14.1.1.3" xref="S2.p2.14.m14.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="S2.p2.14.m14.1b"><apply id="S2.p2.14.m14.1.1.cmml" xref="S2.p2.14.m14.1.1"><csymbol cd="ambiguous" id="S2.p2.14.m14.1.1.1.cmml" xref="S2.p2.14.m14.1.1">subscript</csymbol><ci id="S2.p2.14.m14.1.1.2.cmml" xref="S2.p2.14.m14.1.1.2">𝑠</ci><cn id="S2.p2.14.m14.1.1.3.cmml" type="integer" xref="S2.p2.14.m14.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.14.m14.1c">s_{2}</annotation><annotation encoding="application/x-llamapun" id="S2.p2.14.m14.1d">italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT</annotation></semantics></math> by searching for <math alttext="P[0..e_{1}+1]" class="ltx_math_unparsed" display="inline" id="S2.p2.15.m15.1"><semantics id="S2.p2.15.m15.1a"><mrow id="S2.p2.15.m15.1b"><mi id="S2.p2.15.m15.1.1">P</mi><mrow id="S2.p2.15.m15.1.2"><mo id="S2.p2.15.m15.1.2.1" stretchy="false">[</mo><mn id="S2.p2.15.m15.1.2.2">0</mn><mo id="S2.p2.15.m15.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p2.15.m15.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><msub id="S2.p2.15.m15.1.2.5"><mi id="S2.p2.15.m15.1.2.5.2">e</mi><mn id="S2.p2.15.m15.1.2.5.3">1</mn></msub><mo id="S2.p2.15.m15.1.2.6">+</mo><mn id="S2.p2.15.m15.1.2.7">1</mn><mo id="S2.p2.15.m15.1.2.8" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p2.15.m15.1c">P[0..e_{1}+1]</annotation><annotation encoding="application/x-llamapun" id="S2.p2.15.m15.1d">italic_P [ 0 . . italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + 1 ]</annotation></semantics></math> in the index for <math alttext="T" class="ltx_Math" display="inline" id="S2.p2.16.m16.1"><semantics id="S2.p2.16.m16.1a"><mi id="S2.p2.16.m16.1.1" xref="S2.p2.16.m16.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S2.p2.16.m16.1b"><ci id="S2.p2.16.m16.1.1.cmml" xref="S2.p2.16.m16.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.16.m16.1c">T</annotation><annotation encoding="application/x-llamapun" id="S2.p2.16.m16.1d">italic_T</annotation></semantics></math>. Conceptually, we can then recurse on <math alttext="P[s_{2}..m-1]" class="ltx_math_unparsed" display="inline" id="S2.p2.17.m17.1"><semantics id="S2.p2.17.m17.1a"><mrow id="S2.p2.17.m17.1b"><mi id="S2.p2.17.m17.1.1">P</mi><mrow id="S2.p2.17.m17.1.2"><mo id="S2.p2.17.m17.1.2.1" stretchy="false">[</mo><msub id="S2.p2.17.m17.1.2.2"><mi id="S2.p2.17.m17.1.2.2.2">s</mi><mn id="S2.p2.17.m17.1.2.2.3">2</mn></msub><mo id="S2.p2.17.m17.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p2.17.m17.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S2.p2.17.m17.1.2.5">m</mi><mo id="S2.p2.17.m17.1.2.6">−</mo><mn id="S2.p2.17.m17.1.2.7">1</mn><mo id="S2.p2.17.m17.1.2.8" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p2.17.m17.1c">P[s_{2}..m-1]</annotation><annotation encoding="application/x-llamapun" id="S2.p2.17.m17.1d">italic_P [ italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT . . italic_m - 1 ]</annotation></semantics></math> and find <math alttext="e_{2}" class="ltx_Math" display="inline" id="S2.p2.18.m18.1"><semantics id="S2.p2.18.m18.1a"><msub id="S2.p2.18.m18.1.1" xref="S2.p2.18.m18.1.1.cmml"><mi id="S2.p2.18.m18.1.1.2" xref="S2.p2.18.m18.1.1.2.cmml">e</mi><mn id="S2.p2.18.m18.1.1.3" xref="S2.p2.18.m18.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="S2.p2.18.m18.1b"><apply id="S2.p2.18.m18.1.1.cmml" xref="S2.p2.18.m18.1.1"><csymbol cd="ambiguous" id="S2.p2.18.m18.1.1.1.cmml" xref="S2.p2.18.m18.1.1">subscript</csymbol><ci id="S2.p2.18.m18.1.1.2.cmml" xref="S2.p2.18.m18.1.1.2">𝑒</ci><cn id="S2.p2.18.m18.1.1.3.cmml" type="integer" xref="S2.p2.18.m18.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.18.m18.1c">e_{2}</annotation><annotation encoding="application/x-llamapun" id="S2.p2.18.m18.1d">italic_e start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT</annotation></semantics></math> and the remaining MEMs. The number of backward steps this takes in the indexes is proportional to the total length of the MEMs.</p>
</div>
<div class="ltx_para" id="S2.p3">
<p class="ltx_p" id="S2.p3.14">For many applications we are interested only in long MEMs, which are biologically significant since they are unlikely to be the result of noise. Unfortunately, the total length of the MEMs is often dominated by many short MEMs, which we would like to ignore. Suppose we are interested only in MEMs of length at least <math alttext="L" class="ltx_Math" display="inline" id="S2.p3.1.m1.1"><semantics id="S2.p3.1.m1.1a"><mi id="S2.p3.1.m1.1.1" xref="S2.p3.1.m1.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="S2.p3.1.m1.1b"><ci id="S2.p3.1.m1.1.1.cmml" xref="S2.p3.1.m1.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p3.1.m1.1c">L</annotation><annotation encoding="application/x-llamapun" id="S2.p3.1.m1.1d">italic_L</annotation></semantics></math>. Gagie <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib8" title="">8</a>]</cite> recently observed that any such MEM starting in <math alttext="P[0..L-1]" class="ltx_math_unparsed" display="inline" id="S2.p3.2.m2.1"><semantics id="S2.p3.2.m2.1a"><mrow id="S2.p3.2.m2.1b"><mi id="S2.p3.2.m2.1.1">P</mi><mrow id="S2.p3.2.m2.1.2"><mo id="S2.p3.2.m2.1.2.1" stretchy="false">[</mo><mn id="S2.p3.2.m2.1.2.2">0</mn><mo id="S2.p3.2.m2.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p3.2.m2.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S2.p3.2.m2.1.2.5">L</mi><mo id="S2.p3.2.m2.1.2.6">−</mo><mn id="S2.p3.2.m2.1.2.7">1</mn><mo id="S2.p3.2.m2.1.2.8" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p3.2.m2.1c">P[0..L-1]</annotation><annotation encoding="application/x-llamapun" id="S2.p3.2.m2.1d">italic_P [ 0 . . italic_L - 1 ]</annotation></semantics></math> includes <math alttext="P[L-1]" class="ltx_Math" display="inline" id="S2.p3.3.m3.1"><semantics id="S2.p3.3.m3.1a"><mrow id="S2.p3.3.m3.1.1" xref="S2.p3.3.m3.1.1.cmml"><mi id="S2.p3.3.m3.1.1.3" xref="S2.p3.3.m3.1.1.3.cmml">P</mi><mo id="S2.p3.3.m3.1.1.2" xref="S2.p3.3.m3.1.1.2.cmml">⁢</mo><mrow id="S2.p3.3.m3.1.1.1.1" xref="S2.p3.3.m3.1.1.1.2.cmml"><mo id="S2.p3.3.m3.1.1.1.1.2" stretchy="false" xref="S2.p3.3.m3.1.1.1.2.1.cmml">[</mo><mrow id="S2.p3.3.m3.1.1.1.1.1" xref="S2.p3.3.m3.1.1.1.1.1.cmml"><mi id="S2.p3.3.m3.1.1.1.1.1.2" xref="S2.p3.3.m3.1.1.1.1.1.2.cmml">L</mi><mo id="S2.p3.3.m3.1.1.1.1.1.1" xref="S2.p3.3.m3.1.1.1.1.1.1.cmml">−</mo><mn id="S2.p3.3.m3.1.1.1.1.1.3" xref="S2.p3.3.m3.1.1.1.1.1.3.cmml">1</mn></mrow><mo id="S2.p3.3.m3.1.1.1.1.3" stretchy="false" xref="S2.p3.3.m3.1.1.1.2.1.cmml">]</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p3.3.m3.1b"><apply id="S2.p3.3.m3.1.1.cmml" xref="S2.p3.3.m3.1.1"><times id="S2.p3.3.m3.1.1.2.cmml" xref="S2.p3.3.m3.1.1.2"></times><ci id="S2.p3.3.m3.1.1.3.cmml" xref="S2.p3.3.m3.1.1.3">𝑃</ci><apply id="S2.p3.3.m3.1.1.1.2.cmml" xref="S2.p3.3.m3.1.1.1.1"><csymbol cd="latexml" id="S2.p3.3.m3.1.1.1.2.1.cmml" xref="S2.p3.3.m3.1.1.1.1.2">delimited-[]</csymbol><apply id="S2.p3.3.m3.1.1.1.1.1.cmml" xref="S2.p3.3.m3.1.1.1.1.1"><minus id="S2.p3.3.m3.1.1.1.1.1.1.cmml" xref="S2.p3.3.m3.1.1.1.1.1.1"></minus><ci id="S2.p3.3.m3.1.1.1.1.1.2.cmml" xref="S2.p3.3.m3.1.1.1.1.1.2">𝐿</ci><cn id="S2.p3.3.m3.1.1.1.1.1.3.cmml" type="integer" xref="S2.p3.3.m3.1.1.1.1.1.3">1</cn></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p3.3.m3.1c">P[L-1]</annotation><annotation encoding="application/x-llamapun" id="S2.p3.3.m3.1d">italic_P [ italic_L - 1 ]</annotation></semantics></math>, so if we search for <math alttext="P[0..L-1]" class="ltx_math_unparsed" display="inline" id="S2.p3.4.m4.1"><semantics id="S2.p3.4.m4.1a"><mrow id="S2.p3.4.m4.1b"><mi id="S2.p3.4.m4.1.1">P</mi><mrow id="S2.p3.4.m4.1.2"><mo id="S2.p3.4.m4.1.2.1" stretchy="false">[</mo><mn id="S2.p3.4.m4.1.2.2">0</mn><mo id="S2.p3.4.m4.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p3.4.m4.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S2.p3.4.m4.1.2.5">L</mi><mo id="S2.p3.4.m4.1.2.6">−</mo><mn id="S2.p3.4.m4.1.2.7">1</mn><mo id="S2.p3.4.m4.1.2.8" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p3.4.m4.1c">P[0..L-1]</annotation><annotation encoding="application/x-llamapun" id="S2.p3.4.m4.1d">italic_P [ 0 . . italic_L - 1 ]</annotation></semantics></math> in the index for <math alttext="T" class="ltx_Math" display="inline" id="S2.p3.5.m5.1"><semantics id="S2.p3.5.m5.1a"><mi id="S2.p3.5.m5.1.1" xref="S2.p3.5.m5.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S2.p3.5.m5.1b"><ci id="S2.p3.5.m5.1.1.cmml" xref="S2.p3.5.m5.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p3.5.m5.1c">T</annotation><annotation encoding="application/x-llamapun" id="S2.p3.5.m5.1d">italic_T</annotation></semantics></math> and find that <math alttext="P[s..L-1]" class="ltx_math_unparsed" display="inline" id="S2.p3.6.m6.1"><semantics id="S2.p3.6.m6.1a"><mrow id="S2.p3.6.m6.1b"><mi id="S2.p3.6.m6.1.1">P</mi><mrow id="S2.p3.6.m6.1.2"><mo id="S2.p3.6.m6.1.2.1" stretchy="false">[</mo><mi id="S2.p3.6.m6.1.2.2">s</mi><mo id="S2.p3.6.m6.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p3.6.m6.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S2.p3.6.m6.1.2.5">L</mi><mo id="S2.p3.6.m6.1.2.6">−</mo><mn id="S2.p3.6.m6.1.2.7">1</mn><mo id="S2.p3.6.m6.1.2.8" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p3.6.m6.1c">P[s..L-1]</annotation><annotation encoding="application/x-llamapun" id="S2.p3.6.m6.1d">italic_P [ italic_s . . italic_L - 1 ]</annotation></semantics></math> occurs in <math alttext="T" class="ltx_Math" display="inline" id="S2.p3.7.m7.1"><semantics id="S2.p3.7.m7.1a"><mi id="S2.p3.7.m7.1.1" xref="S2.p3.7.m7.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S2.p3.7.m7.1b"><ci id="S2.p3.7.m7.1.1.cmml" xref="S2.p3.7.m7.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p3.7.m7.1c">T</annotation><annotation encoding="application/x-llamapun" id="S2.p3.7.m7.1d">italic_T</annotation></semantics></math> but <math alttext="P[s-1..L-1]" class="ltx_math_unparsed" display="inline" id="S2.p3.8.m8.1"><semantics id="S2.p3.8.m8.1a"><mrow id="S2.p3.8.m8.1b"><mi id="S2.p3.8.m8.1.1">P</mi><mrow id="S2.p3.8.m8.1.2"><mo id="S2.p3.8.m8.1.2.1" stretchy="false">[</mo><mi id="S2.p3.8.m8.1.2.2">s</mi><mo id="S2.p3.8.m8.1.2.3">−</mo><mn id="S2.p3.8.m8.1.2.4">1</mn><mo id="S2.p3.8.m8.1.2.5" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p3.8.m8.1.2.6" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S2.p3.8.m8.1.2.7">L</mi><mo id="S2.p3.8.m8.1.2.8">−</mo><mn id="S2.p3.8.m8.1.2.9">1</mn><mo id="S2.p3.8.m8.1.2.10" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p3.8.m8.1c">P[s-1..L-1]</annotation><annotation encoding="application/x-llamapun" id="S2.p3.8.m8.1d">italic_P [ italic_s - 1 . . italic_L - 1 ]</annotation></semantics></math> does not, for some <math alttext="s&gt;1" class="ltx_Math" display="inline" id="S2.p3.9.m9.1"><semantics id="S2.p3.9.m9.1a"><mrow id="S2.p3.9.m9.1.1" xref="S2.p3.9.m9.1.1.cmml"><mi id="S2.p3.9.m9.1.1.2" xref="S2.p3.9.m9.1.1.2.cmml">s</mi><mo id="S2.p3.9.m9.1.1.1" xref="S2.p3.9.m9.1.1.1.cmml">&gt;</mo><mn id="S2.p3.9.m9.1.1.3" xref="S2.p3.9.m9.1.1.3.cmml">1</mn></mrow><annotation-xml encoding="MathML-Content" id="S2.p3.9.m9.1b"><apply id="S2.p3.9.m9.1.1.cmml" xref="S2.p3.9.m9.1.1"><gt id="S2.p3.9.m9.1.1.1.cmml" xref="S2.p3.9.m9.1.1.1"></gt><ci id="S2.p3.9.m9.1.1.2.cmml" xref="S2.p3.9.m9.1.1.2">𝑠</ci><cn id="S2.p3.9.m9.1.1.3.cmml" type="integer" xref="S2.p3.9.m9.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p3.9.m9.1c">s&gt;1</annotation><annotation encoding="application/x-llamapun" id="S2.p3.9.m9.1d">italic_s &gt; 1</annotation></semantics></math>, then we can ignore <math alttext="P[0..s-1]" class="ltx_math_unparsed" display="inline" id="S2.p3.10.m10.1"><semantics id="S2.p3.10.m10.1a"><mrow id="S2.p3.10.m10.1b"><mi id="S2.p3.10.m10.1.1">P</mi><mrow id="S2.p3.10.m10.1.2"><mo id="S2.p3.10.m10.1.2.1" stretchy="false">[</mo><mn id="S2.p3.10.m10.1.2.2">0</mn><mo id="S2.p3.10.m10.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p3.10.m10.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S2.p3.10.m10.1.2.5">s</mi><mo id="S2.p3.10.m10.1.2.6">−</mo><mn id="S2.p3.10.m10.1.2.7">1</mn><mo id="S2.p3.10.m10.1.2.8" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p3.10.m10.1c">P[0..s-1]</annotation><annotation encoding="application/x-llamapun" id="S2.p3.10.m10.1d">italic_P [ 0 . . italic_s - 1 ]</annotation></semantics></math> and recurse on <math alttext="P[s..m-1]" class="ltx_math_unparsed" display="inline" id="S2.p3.11.m11.1"><semantics id="S2.p3.11.m11.1a"><mrow id="S2.p3.11.m11.1b"><mi id="S2.p3.11.m11.1.1">P</mi><mrow id="S2.p3.11.m11.1.2"><mo id="S2.p3.11.m11.1.2.1" stretchy="false">[</mo><mi id="S2.p3.11.m11.1.2.2">s</mi><mo id="S2.p3.11.m11.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p3.11.m11.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S2.p3.11.m11.1.2.5">m</mi><mo id="S2.p3.11.m11.1.2.6">−</mo><mn id="S2.p3.11.m11.1.2.7">1</mn><mo id="S2.p3.11.m11.1.2.8" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p3.11.m11.1c">P[s..m-1]</annotation><annotation encoding="application/x-llamapun" id="S2.p3.11.m11.1d">italic_P [ italic_s . . italic_m - 1 ]</annotation></semantics></math>. If we find that all of <math alttext="P[0..L-1]" class="ltx_math_unparsed" display="inline" id="S2.p3.12.m12.1"><semantics id="S2.p3.12.m12.1a"><mrow id="S2.p3.12.m12.1b"><mi id="S2.p3.12.m12.1.1">P</mi><mrow id="S2.p3.12.m12.1.2"><mo id="S2.p3.12.m12.1.2.1" stretchy="false">[</mo><mn id="S2.p3.12.m12.1.2.2">0</mn><mo id="S2.p3.12.m12.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S2.p3.12.m12.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S2.p3.12.m12.1.2.5">L</mi><mo id="S2.p3.12.m12.1.2.6">−</mo><mn id="S2.p3.12.m12.1.2.7">1</mn><mo id="S2.p3.12.m12.1.2.8" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S2.p3.12.m12.1c">P[0..L-1]</annotation><annotation encoding="application/x-llamapun" id="S2.p3.12.m12.1d">italic_P [ 0 . . italic_L - 1 ]</annotation></semantics></math> occurs in <math alttext="T" class="ltx_Math" display="inline" id="S2.p3.13.m13.1"><semantics id="S2.p3.13.m13.1a"><mi id="S2.p3.13.m13.1.1" xref="S2.p3.13.m13.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S2.p3.13.m13.1b"><ci id="S2.p3.13.m13.1.1.cmml" xref="S2.p3.13.m13.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p3.13.m13.1c">T</annotation><annotation encoding="application/x-llamapun" id="S2.p3.13.m13.1d">italic_T</annotation></semantics></math> then we can still use the first few steps of forward-backward to find the leftmost MEM and the starting position of the second MEM from the left in <math alttext="P" class="ltx_Math" display="inline" id="S2.p3.14.m14.1"><semantics id="S2.p3.14.m14.1a"><mi id="S2.p3.14.m14.1.1" xref="S2.p3.14.m14.1.1.cmml">P</mi><annotation-xml encoding="MathML-Content" id="S2.p3.14.m14.1b"><ci id="S2.p3.14.m14.1.1.cmml" xref="S2.p3.14.m14.1.1">𝑃</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p3.14.m14.1c">P</annotation><annotation encoding="application/x-llamapun" id="S2.p3.14.m14.1d">italic_P</annotation></semantics></math>, and then recurse. Since this approach is reminiscent of Boyer-Moore pattern matching, we call it <span class="ltx_text ltx_font_italic" id="S2.p3.14.1">Boyer-Moore-Li</span> (BML). Li <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib10" title="">10</a>]</cite> incorporated BML into <span class="ltx_text ltx_font_typewriter" id="S2.p3.14.2">ropebwt3</span> and found it significantly accelerates MEM-finding.</p>
</div>
</section>
<section class="ltx_section" id="S3">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">3 </span><math alttext="k" class="ltx_Math" display="inline" id="S3.1.m1.1"><semantics id="S3.1.m1.1b"><mi id="S3.1.m1.1.1" xref="S3.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S3.1.m1.1c"><ci id="S3.1.m1.1.1.cmml" xref="S3.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.1.m1.1d">k</annotation><annotation encoding="application/x-llamapun" id="S3.1.m1.1e">italic_k</annotation></semantics></math>-mer based breaking into pseudo-MEMs</h2>
<div class="ltx_para" id="S3.p1">
<p class="ltx_p" id="S3.p1.2">Another technique for speeding up pattern matching is <math alttext="k" class="ltx_Math" display="inline" id="S3.p1.1.m1.1"><semantics id="S3.p1.1.m1.1a"><mi id="S3.p1.1.m1.1.1" xref="S3.p1.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S3.p1.1.m1.1b"><ci id="S3.p1.1.m1.1.1.cmml" xref="S3.p1.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p1.1.m1.1c">k</annotation><annotation encoding="application/x-llamapun" id="S3.p1.1.m1.1d">italic_k</annotation></semantics></math><span class="ltx_text ltx_font_italic" id="S3.p1.2.1">-mer filtration</span>. In contrast to BML, this requires
scanning the whole input and deciding which parts can be ignored because they cannot contain significant-length matches. If the alphabet’s size is polylogarithmic in <math alttext="n" class="ltx_Math" display="inline" id="S3.p1.2.m2.1"><semantics id="S3.p1.2.m2.1a"><mi id="S3.p1.2.m2.1.1" xref="S3.p1.2.m2.1.1.cmml">n</mi><annotation-xml encoding="MathML-Content" id="S3.p1.2.m2.1b"><ci id="S3.p1.2.m2.1.1.cmml" xref="S3.p1.2.m2.1.1">𝑛</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p1.2.m2.1c">n</annotation><annotation encoding="application/x-llamapun" id="S3.p1.2.m2.1d">italic_n</annotation></semantics></math> and BML uses a sublinear number of backward steps, then in the word-RAM model filtration is asymptotically slower;
however, the filtration scan is sequential, incurring few cache misses and allowing it to be fast in practice compared to FM-index queries, which tend to incur many cache misses.</p>
</div>
<div class="ltx_para" id="S3.p2">
<p class="ltx_p" id="S3.p2.15">Suppose we are given <math alttext="k" class="ltx_Math" display="inline" id="S3.p2.1.m1.1"><semantics id="S3.p2.1.m1.1a"><mi id="S3.p2.1.m1.1.1" xref="S3.p2.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S3.p2.1.m1.1b"><ci id="S3.p2.1.m1.1.1.cmml" xref="S3.p2.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p2.1.m1.1c">k</annotation><annotation encoding="application/x-llamapun" id="S3.p2.1.m1.1d">italic_k</annotation></semantics></math> when we index <math alttext="T" class="ltx_Math" display="inline" id="S3.p2.2.m2.1"><semantics id="S3.p2.2.m2.1a"><mi id="S3.p2.2.m2.1.1" xref="S3.p2.2.m2.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S3.p2.2.m2.1b"><ci id="S3.p2.2.m2.1.1.cmml" xref="S3.p2.2.m2.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p2.2.m2.1c">T</annotation><annotation encoding="application/x-llamapun" id="S3.p2.2.m2.1d">italic_T</annotation></semantics></math> and we build a Bloom filter <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib2" title="">2</a>]</cite> for the distinct <math alttext="k" class="ltx_Math" display="inline" id="S3.p2.3.m3.1"><semantics id="S3.p2.3.m3.1a"><mi id="S3.p2.3.m3.1.1" xref="S3.p2.3.m3.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S3.p2.3.m3.1b"><ci id="S3.p2.3.m3.1.1.cmml" xref="S3.p2.3.m3.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p2.3.m3.1c">k</annotation><annotation encoding="application/x-llamapun" id="S3.p2.3.m3.1d">italic_k</annotation></semantics></math>-mers in <math alttext="T" class="ltx_Math" display="inline" id="S3.p2.4.m4.1"><semantics id="S3.p2.4.m4.1a"><mi id="S3.p2.4.m4.1.1" xref="S3.p2.4.m4.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S3.p2.4.m4.1b"><ci id="S3.p2.4.m4.1.1.cmml" xref="S3.p2.4.m4.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p2.4.m4.1c">T</annotation><annotation encoding="application/x-llamapun" id="S3.p2.4.m4.1d">italic_T</annotation></semantics></math>. Bloom filters can give false-positive results but not false-negative ones, so if the filter answers “no” for a <math alttext="k" class="ltx_Math" display="inline" id="S3.p2.5.m5.1"><semantics id="S3.p2.5.m5.1a"><mi id="S3.p2.5.m5.1.1" xref="S3.p2.5.m5.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S3.p2.5.m5.1b"><ci id="S3.p2.5.m5.1.1.cmml" xref="S3.p2.5.m5.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p2.5.m5.1c">k</annotation><annotation encoding="application/x-llamapun" id="S3.p2.5.m5.1d">italic_k</annotation></semantics></math>-mer <math alttext="P[i..i+k-1]" class="ltx_math_unparsed" display="inline" id="S3.p2.6.m6.1"><semantics id="S3.p2.6.m6.1a"><mrow id="S3.p2.6.m6.1b"><mi id="S3.p2.6.m6.1.1">P</mi><mrow id="S3.p2.6.m6.1.2"><mo id="S3.p2.6.m6.1.2.1" stretchy="false">[</mo><mi id="S3.p2.6.m6.1.2.2">i</mi><mo id="S3.p2.6.m6.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="S3.p2.6.m6.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="S3.p2.6.m6.1.2.5">i</mi><mo id="S3.p2.6.m6.1.2.6">+</mo><mi id="S3.p2.6.m6.1.2.7">k</mi><mo id="S3.p2.6.m6.1.2.8">−</mo><mn id="S3.p2.6.m6.1.2.9">1</mn><mo id="S3.p2.6.m6.1.2.10" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="S3.p2.6.m6.1c">P[i..i+k-1]</annotation><annotation encoding="application/x-llamapun" id="S3.p2.6.m6.1d">italic_P [ italic_i . . italic_i + italic_k - 1 ]</annotation></semantics></math> then no MEM of length at least <math alttext="k" class="ltx_Math" display="inline" id="S3.p2.7.m7.1"><semantics id="S3.p2.7.m7.1a"><mi id="S3.p2.7.m7.1.1" xref="S3.p2.7.m7.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S3.p2.7.m7.1b"><ci id="S3.p2.7.m7.1.1.cmml" xref="S3.p2.7.m7.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p2.7.m7.1c">k</annotation><annotation encoding="application/x-llamapun" id="S3.p2.7.m7.1d">italic_k</annotation></semantics></math> includes that <math alttext="k" class="ltx_Math" display="inline" id="S3.p2.8.m8.1"><semantics id="S3.p2.8.m8.1a"><mi id="S3.p2.8.m8.1.1" xref="S3.p2.8.m8.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S3.p2.8.m8.1b"><ci id="S3.p2.8.m8.1.1.cmml" xref="S3.p2.8.m8.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p2.8.m8.1c">k</annotation><annotation encoding="application/x-llamapun" id="S3.p2.8.m8.1d">italic_k</annotation></semantics></math>-mer. It follows that when we are given <math alttext="P" class="ltx_Math" display="inline" id="S3.p2.9.m9.1"><semantics id="S3.p2.9.m9.1a"><mi id="S3.p2.9.m9.1.1" xref="S3.p2.9.m9.1.1.cmml">P</mi><annotation-xml encoding="MathML-Content" id="S3.p2.9.m9.1b"><ci id="S3.p2.9.m9.1.1.cmml" xref="S3.p2.9.m9.1.1">𝑃</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p2.9.m9.1c">P</annotation><annotation encoding="application/x-llamapun" id="S3.p2.9.m9.1d">italic_P</annotation></semantics></math> and <math alttext="L&gt;k" class="ltx_Math" display="inline" id="S3.p2.10.m10.1"><semantics id="S3.p2.10.m10.1a"><mrow id="S3.p2.10.m10.1.1" xref="S3.p2.10.m10.1.1.cmml"><mi id="S3.p2.10.m10.1.1.2" xref="S3.p2.10.m10.1.1.2.cmml">L</mi><mo id="S3.p2.10.m10.1.1.1" xref="S3.p2.10.m10.1.1.1.cmml">&gt;</mo><mi id="S3.p2.10.m10.1.1.3" xref="S3.p2.10.m10.1.1.3.cmml">k</mi></mrow><annotation-xml encoding="MathML-Content" id="S3.p2.10.m10.1b"><apply id="S3.p2.10.m10.1.1.cmml" xref="S3.p2.10.m10.1.1"><gt id="S3.p2.10.m10.1.1.1.cmml" xref="S3.p2.10.m10.1.1.1"></gt><ci id="S3.p2.10.m10.1.1.2.cmml" xref="S3.p2.10.m10.1.1.2">𝐿</ci><ci id="S3.p2.10.m10.1.1.3.cmml" xref="S3.p2.10.m10.1.1.3">𝑘</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.p2.10.m10.1c">L&gt;k</annotation><annotation encoding="application/x-llamapun" id="S3.p2.10.m10.1d">italic_L &gt; italic_k</annotation></semantics></math>, we can break <math alttext="P" class="ltx_Math" display="inline" id="S3.p2.11.m11.1"><semantics id="S3.p2.11.m11.1a"><mi id="S3.p2.11.m11.1.1" xref="S3.p2.11.m11.1.1.cmml">P</mi><annotation-xml encoding="MathML-Content" id="S3.p2.11.m11.1b"><ci id="S3.p2.11.m11.1.1.cmml" xref="S3.p2.11.m11.1.1">𝑃</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p2.11.m11.1c">P</annotation><annotation encoding="application/x-llamapun" id="S3.p2.11.m11.1d">italic_P</annotation></semantics></math> up into maximal substrings — which can overlap by <math alttext="k-2" class="ltx_Math" display="inline" id="S3.p2.12.m12.1"><semantics id="S3.p2.12.m12.1a"><mrow id="S3.p2.12.m12.1.1" xref="S3.p2.12.m12.1.1.cmml"><mi id="S3.p2.12.m12.1.1.2" xref="S3.p2.12.m12.1.1.2.cmml">k</mi><mo id="S3.p2.12.m12.1.1.1" xref="S3.p2.12.m12.1.1.1.cmml">−</mo><mn id="S3.p2.12.m12.1.1.3" xref="S3.p2.12.m12.1.1.3.cmml">2</mn></mrow><annotation-xml encoding="MathML-Content" id="S3.p2.12.m12.1b"><apply id="S3.p2.12.m12.1.1.cmml" xref="S3.p2.12.m12.1.1"><minus id="S3.p2.12.m12.1.1.1.cmml" xref="S3.p2.12.m12.1.1.1"></minus><ci id="S3.p2.12.m12.1.1.2.cmml" xref="S3.p2.12.m12.1.1.2">𝑘</ci><cn id="S3.p2.12.m12.1.1.3.cmml" type="integer" xref="S3.p2.12.m12.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.p2.12.m12.1c">k-2</annotation><annotation encoding="application/x-llamapun" id="S3.p2.12.m12.1d">italic_k - 2</annotation></semantics></math> characters but cannot nest — containing only <math alttext="k" class="ltx_Math" display="inline" id="S3.p2.13.m13.1"><semantics id="S3.p2.13.m13.1a"><mi id="S3.p2.13.m13.1.1" xref="S3.p2.13.m13.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S3.p2.13.m13.1b"><ci id="S3.p2.13.m13.1.1.cmml" xref="S3.p2.13.m13.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p2.13.m13.1c">k</annotation><annotation encoding="application/x-llamapun" id="S3.p2.13.m13.1d">italic_k</annotation></semantics></math>-mers for which the filter answers “yes”, that contain all the MEMs of length at least <math alttext="L" class="ltx_Math" display="inline" id="S3.p2.14.m14.1"><semantics id="S3.p2.14.m14.1a"><mi id="S3.p2.14.m14.1.1" xref="S3.p2.14.m14.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="S3.p2.14.m14.1b"><ci id="S3.p2.14.m14.1.1.cmml" xref="S3.p2.14.m14.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p2.14.m14.1c">L</annotation><annotation encoding="application/x-llamapun" id="S3.p2.14.m14.1d">italic_L</annotation></semantics></math>. We call these substrings <span class="ltx_text ltx_font_italic" id="S3.p2.15.1">pseudo-MEMs</span> because they are our best guesses at the MEMs of length at least <math alttext="L" class="ltx_Math" display="inline" id="S3.p2.15.m15.1"><semantics id="S3.p2.15.m15.1a"><mi id="S3.p2.15.m15.1.1" xref="S3.p2.15.m15.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="S3.p2.15.m15.1b"><ci id="S3.p2.15.m15.1.1.cmml" xref="S3.p2.15.m15.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p2.15.m15.1c">L</annotation><annotation encoding="application/x-llamapun" id="S3.p2.15.m15.1d">italic_L</annotation></semantics></math> based on the information we can glean from the filter.</p>
</div>
<div class="ltx_theorem ltx_theorem_definition" id="Thmdefinition1">
<h6 class="ltx_title ltx_font_bold ltx_title_theorem"><span class="ltx_tag ltx_tag_theorem">Definition 1</span></h6>
<div class="ltx_para" id="Thmdefinition1.p1">
<p class="ltx_p" id="Thmdefinition1.p1.11">A <span class="ltx_text ltx_font_italic" id="Thmdefinition1.p1.11.1">pseudo-MEM</span> of a pattern <math alttext="P[0..m-1]" class="ltx_math_unparsed" display="inline" id="Thmdefinition1.p1.1.m1.1"><semantics id="Thmdefinition1.p1.1.m1.1a"><mrow id="Thmdefinition1.p1.1.m1.1b"><mi id="Thmdefinition1.p1.1.m1.1.1">P</mi><mrow id="Thmdefinition1.p1.1.m1.1.2"><mo id="Thmdefinition1.p1.1.m1.1.2.1" stretchy="false">[</mo><mn id="Thmdefinition1.p1.1.m1.1.2.2">0</mn><mo id="Thmdefinition1.p1.1.m1.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="Thmdefinition1.p1.1.m1.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="Thmdefinition1.p1.1.m1.1.2.5">m</mi><mo id="Thmdefinition1.p1.1.m1.1.2.6">−</mo><mn id="Thmdefinition1.p1.1.m1.1.2.7">1</mn><mo id="Thmdefinition1.p1.1.m1.1.2.8" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="Thmdefinition1.p1.1.m1.1c">P[0..m-1]</annotation><annotation encoding="application/x-llamapun" id="Thmdefinition1.p1.1.m1.1d">italic_P [ 0 . . italic_m - 1 ]</annotation></semantics></math> with respect to a text <math alttext="T[0..n-1]" class="ltx_math_unparsed" display="inline" id="Thmdefinition1.p1.2.m2.1"><semantics id="Thmdefinition1.p1.2.m2.1a"><mrow id="Thmdefinition1.p1.2.m2.1b"><mi id="Thmdefinition1.p1.2.m2.1.1">T</mi><mrow id="Thmdefinition1.p1.2.m2.1.2"><mo id="Thmdefinition1.p1.2.m2.1.2.1" stretchy="false">[</mo><mn id="Thmdefinition1.p1.2.m2.1.2.2">0</mn><mo id="Thmdefinition1.p1.2.m2.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="Thmdefinition1.p1.2.m2.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="Thmdefinition1.p1.2.m2.1.2.5">n</mi><mo id="Thmdefinition1.p1.2.m2.1.2.6">−</mo><mn id="Thmdefinition1.p1.2.m2.1.2.7">1</mn><mo id="Thmdefinition1.p1.2.m2.1.2.8" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="Thmdefinition1.p1.2.m2.1c">T[0..n-1]</annotation><annotation encoding="application/x-llamapun" id="Thmdefinition1.p1.2.m2.1d">italic_T [ 0 . . italic_n - 1 ]</annotation></semantics></math>, an integer <math alttext="k\geq 1" class="ltx_Math" display="inline" id="Thmdefinition1.p1.3.m3.1"><semantics id="Thmdefinition1.p1.3.m3.1a"><mrow id="Thmdefinition1.p1.3.m3.1.1" xref="Thmdefinition1.p1.3.m3.1.1.cmml"><mi id="Thmdefinition1.p1.3.m3.1.1.2" xref="Thmdefinition1.p1.3.m3.1.1.2.cmml">k</mi><mo id="Thmdefinition1.p1.3.m3.1.1.1" xref="Thmdefinition1.p1.3.m3.1.1.1.cmml">≥</mo><mn id="Thmdefinition1.p1.3.m3.1.1.3" xref="Thmdefinition1.p1.3.m3.1.1.3.cmml">1</mn></mrow><annotation-xml encoding="MathML-Content" id="Thmdefinition1.p1.3.m3.1b"><apply id="Thmdefinition1.p1.3.m3.1.1.cmml" xref="Thmdefinition1.p1.3.m3.1.1"><geq id="Thmdefinition1.p1.3.m3.1.1.1.cmml" xref="Thmdefinition1.p1.3.m3.1.1.1"></geq><ci id="Thmdefinition1.p1.3.m3.1.1.2.cmml" xref="Thmdefinition1.p1.3.m3.1.1.2">𝑘</ci><cn id="Thmdefinition1.p1.3.m3.1.1.3.cmml" type="integer" xref="Thmdefinition1.p1.3.m3.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="Thmdefinition1.p1.3.m3.1c">k\geq 1</annotation><annotation encoding="application/x-llamapun" id="Thmdefinition1.p1.3.m3.1d">italic_k ≥ 1</annotation></semantics></math>, a given Bloom filter for the distinct <math alttext="k" class="ltx_Math" display="inline" id="Thmdefinition1.p1.4.m4.1"><semantics id="Thmdefinition1.p1.4.m4.1a"><mi id="Thmdefinition1.p1.4.m4.1.1" xref="Thmdefinition1.p1.4.m4.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="Thmdefinition1.p1.4.m4.1b"><ci id="Thmdefinition1.p1.4.m4.1.1.cmml" xref="Thmdefinition1.p1.4.m4.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="Thmdefinition1.p1.4.m4.1c">k</annotation><annotation encoding="application/x-llamapun" id="Thmdefinition1.p1.4.m4.1d">italic_k</annotation></semantics></math>-mers in <math alttext="T" class="ltx_Math" display="inline" id="Thmdefinition1.p1.5.m5.1"><semantics id="Thmdefinition1.p1.5.m5.1a"><mi id="Thmdefinition1.p1.5.m5.1.1" xref="Thmdefinition1.p1.5.m5.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="Thmdefinition1.p1.5.m5.1b"><ci id="Thmdefinition1.p1.5.m5.1.1.cmml" xref="Thmdefinition1.p1.5.m5.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="Thmdefinition1.p1.5.m5.1c">T</annotation><annotation encoding="application/x-llamapun" id="Thmdefinition1.p1.5.m5.1d">italic_T</annotation></semantics></math> and an integer <math alttext="L&gt;k" class="ltx_Math" display="inline" id="Thmdefinition1.p1.6.m6.1"><semantics id="Thmdefinition1.p1.6.m6.1a"><mrow id="Thmdefinition1.p1.6.m6.1.1" xref="Thmdefinition1.p1.6.m6.1.1.cmml"><mi id="Thmdefinition1.p1.6.m6.1.1.2" xref="Thmdefinition1.p1.6.m6.1.1.2.cmml">L</mi><mo id="Thmdefinition1.p1.6.m6.1.1.1" xref="Thmdefinition1.p1.6.m6.1.1.1.cmml">&gt;</mo><mi id="Thmdefinition1.p1.6.m6.1.1.3" xref="Thmdefinition1.p1.6.m6.1.1.3.cmml">k</mi></mrow><annotation-xml encoding="MathML-Content" id="Thmdefinition1.p1.6.m6.1b"><apply id="Thmdefinition1.p1.6.m6.1.1.cmml" xref="Thmdefinition1.p1.6.m6.1.1"><gt id="Thmdefinition1.p1.6.m6.1.1.1.cmml" xref="Thmdefinition1.p1.6.m6.1.1.1"></gt><ci id="Thmdefinition1.p1.6.m6.1.1.2.cmml" xref="Thmdefinition1.p1.6.m6.1.1.2">𝐿</ci><ci id="Thmdefinition1.p1.6.m6.1.1.3.cmml" xref="Thmdefinition1.p1.6.m6.1.1.3">𝑘</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="Thmdefinition1.p1.6.m6.1c">L&gt;k</annotation><annotation encoding="application/x-llamapun" id="Thmdefinition1.p1.6.m6.1d">italic_L &gt; italic_k</annotation></semantics></math>, is any maximal non-empty substring <math alttext="P[i..j]" class="ltx_math_unparsed" display="inline" id="Thmdefinition1.p1.7.m7.1"><semantics id="Thmdefinition1.p1.7.m7.1a"><mrow id="Thmdefinition1.p1.7.m7.1b"><mi id="Thmdefinition1.p1.7.m7.1.1">P</mi><mrow id="Thmdefinition1.p1.7.m7.1.2"><mo id="Thmdefinition1.p1.7.m7.1.2.1" stretchy="false">[</mo><mi id="Thmdefinition1.p1.7.m7.1.2.2">i</mi><mo id="Thmdefinition1.p1.7.m7.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="Thmdefinition1.p1.7.m7.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="Thmdefinition1.p1.7.m7.1.2.5">j</mi><mo id="Thmdefinition1.p1.7.m7.1.2.6" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="Thmdefinition1.p1.7.m7.1c">P[i..j]</annotation><annotation encoding="application/x-llamapun" id="Thmdefinition1.p1.7.m7.1d">italic_P [ italic_i . . italic_j ]</annotation></semantics></math> of <math alttext="P" class="ltx_Math" display="inline" id="Thmdefinition1.p1.8.m8.1"><semantics id="Thmdefinition1.p1.8.m8.1a"><mi id="Thmdefinition1.p1.8.m8.1.1" xref="Thmdefinition1.p1.8.m8.1.1.cmml">P</mi><annotation-xml encoding="MathML-Content" id="Thmdefinition1.p1.8.m8.1b"><ci id="Thmdefinition1.p1.8.m8.1.1.cmml" xref="Thmdefinition1.p1.8.m8.1.1">𝑃</ci></annotation-xml><annotation encoding="application/x-tex" id="Thmdefinition1.p1.8.m8.1c">P</annotation><annotation encoding="application/x-llamapun" id="Thmdefinition1.p1.8.m8.1d">italic_P</annotation></semantics></math> of length at least <math alttext="L" class="ltx_Math" display="inline" id="Thmdefinition1.p1.9.m9.1"><semantics id="Thmdefinition1.p1.9.m9.1a"><mi id="Thmdefinition1.p1.9.m9.1.1" xref="Thmdefinition1.p1.9.m9.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="Thmdefinition1.p1.9.m9.1b"><ci id="Thmdefinition1.p1.9.m9.1.1.cmml" xref="Thmdefinition1.p1.9.m9.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="Thmdefinition1.p1.9.m9.1c">L</annotation><annotation encoding="application/x-llamapun" id="Thmdefinition1.p1.9.m9.1d">italic_L</annotation></semantics></math> such that all the <math alttext="k" class="ltx_Math" display="inline" id="Thmdefinition1.p1.10.m10.1"><semantics id="Thmdefinition1.p1.10.m10.1a"><mi id="Thmdefinition1.p1.10.m10.1.1" xref="Thmdefinition1.p1.10.m10.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="Thmdefinition1.p1.10.m10.1b"><ci id="Thmdefinition1.p1.10.m10.1.1.cmml" xref="Thmdefinition1.p1.10.m10.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="Thmdefinition1.p1.10.m10.1c">k</annotation><annotation encoding="application/x-llamapun" id="Thmdefinition1.p1.10.m10.1d">italic_k</annotation></semantics></math>-mers in <math alttext="P[i..j]" class="ltx_math_unparsed" display="inline" id="Thmdefinition1.p1.11.m11.1"><semantics id="Thmdefinition1.p1.11.m11.1a"><mrow id="Thmdefinition1.p1.11.m11.1b"><mi id="Thmdefinition1.p1.11.m11.1.1">P</mi><mrow id="Thmdefinition1.p1.11.m11.1.2"><mo id="Thmdefinition1.p1.11.m11.1.2.1" stretchy="false">[</mo><mi id="Thmdefinition1.p1.11.m11.1.2.2">i</mi><mo id="Thmdefinition1.p1.11.m11.1.2.3" lspace="0em" rspace="0.0835em">.</mo><mo id="Thmdefinition1.p1.11.m11.1.2.4" lspace="0.0835em" rspace="0.167em">.</mo><mi id="Thmdefinition1.p1.11.m11.1.2.5">j</mi><mo id="Thmdefinition1.p1.11.m11.1.2.6" stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="Thmdefinition1.p1.11.m11.1c">P[i..j]</annotation><annotation encoding="application/x-llamapun" id="Thmdefinition1.p1.11.m11.1d">italic_P [ italic_i . . italic_j ]</annotation></semantics></math> appear in the filter.</p>
</div>
</div>
<div class="ltx_theorem ltx_theorem_proposition" id="Thmproposition1">
<h6 class="ltx_title ltx_font_bold ltx_title_theorem"><span class="ltx_tag ltx_tag_theorem">Proposition 1</span></h6>
<div class="ltx_para" id="Thmproposition1.p1">
<p class="ltx_p" id="Thmproposition1.p1.7"><span class="ltx_text ltx_font_italic" id="Thmproposition1.p1.7.7">All the MEMs of <math alttext="P" class="ltx_Math" display="inline" id="Thmproposition1.p1.1.1.m1.1"><semantics id="Thmproposition1.p1.1.1.m1.1a"><mi id="Thmproposition1.p1.1.1.m1.1.1" xref="Thmproposition1.p1.1.1.m1.1.1.cmml">P</mi><annotation-xml encoding="MathML-Content" id="Thmproposition1.p1.1.1.m1.1b"><ci id="Thmproposition1.p1.1.1.m1.1.1.cmml" xref="Thmproposition1.p1.1.1.m1.1.1">𝑃</ci></annotation-xml><annotation encoding="application/x-tex" id="Thmproposition1.p1.1.1.m1.1c">P</annotation><annotation encoding="application/x-llamapun" id="Thmproposition1.p1.1.1.m1.1d">italic_P</annotation></semantics></math> with respect to <math alttext="T" class="ltx_Math" display="inline" id="Thmproposition1.p1.2.2.m2.1"><semantics id="Thmproposition1.p1.2.2.m2.1a"><mi id="Thmproposition1.p1.2.2.m2.1.1" xref="Thmproposition1.p1.2.2.m2.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="Thmproposition1.p1.2.2.m2.1b"><ci id="Thmproposition1.p1.2.2.m2.1.1.cmml" xref="Thmproposition1.p1.2.2.m2.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="Thmproposition1.p1.2.2.m2.1c">T</annotation><annotation encoding="application/x-llamapun" id="Thmproposition1.p1.2.2.m2.1d">italic_T</annotation></semantics></math> of length at least <math alttext="L&gt;k" class="ltx_Math" display="inline" id="Thmproposition1.p1.3.3.m3.1"><semantics id="Thmproposition1.p1.3.3.m3.1a"><mrow id="Thmproposition1.p1.3.3.m3.1.1" xref="Thmproposition1.p1.3.3.m3.1.1.cmml"><mi id="Thmproposition1.p1.3.3.m3.1.1.2" xref="Thmproposition1.p1.3.3.m3.1.1.2.cmml">L</mi><mo id="Thmproposition1.p1.3.3.m3.1.1.1" xref="Thmproposition1.p1.3.3.m3.1.1.1.cmml">&gt;</mo><mi id="Thmproposition1.p1.3.3.m3.1.1.3" xref="Thmproposition1.p1.3.3.m3.1.1.3.cmml">k</mi></mrow><annotation-xml encoding="MathML-Content" id="Thmproposition1.p1.3.3.m3.1b"><apply id="Thmproposition1.p1.3.3.m3.1.1.cmml" xref="Thmproposition1.p1.3.3.m3.1.1"><gt id="Thmproposition1.p1.3.3.m3.1.1.1.cmml" xref="Thmproposition1.p1.3.3.m3.1.1.1"></gt><ci id="Thmproposition1.p1.3.3.m3.1.1.2.cmml" xref="Thmproposition1.p1.3.3.m3.1.1.2">𝐿</ci><ci id="Thmproposition1.p1.3.3.m3.1.1.3.cmml" xref="Thmproposition1.p1.3.3.m3.1.1.3">𝑘</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="Thmproposition1.p1.3.3.m3.1c">L&gt;k</annotation><annotation encoding="application/x-llamapun" id="Thmproposition1.p1.3.3.m3.1d">italic_L &gt; italic_k</annotation></semantics></math> are contained in the pseudo-MEMs of <math alttext="P" class="ltx_Math" display="inline" id="Thmproposition1.p1.4.4.m4.1"><semantics id="Thmproposition1.p1.4.4.m4.1a"><mi id="Thmproposition1.p1.4.4.m4.1.1" xref="Thmproposition1.p1.4.4.m4.1.1.cmml">P</mi><annotation-xml encoding="MathML-Content" id="Thmproposition1.p1.4.4.m4.1b"><ci id="Thmproposition1.p1.4.4.m4.1.1.cmml" xref="Thmproposition1.p1.4.4.m4.1.1">𝑃</ci></annotation-xml><annotation encoding="application/x-tex" id="Thmproposition1.p1.4.4.m4.1c">P</annotation><annotation encoding="application/x-llamapun" id="Thmproposition1.p1.4.4.m4.1d">italic_P</annotation></semantics></math> with respect to <math alttext="T" class="ltx_Math" display="inline" id="Thmproposition1.p1.5.5.m5.1"><semantics id="Thmproposition1.p1.5.5.m5.1a"><mi id="Thmproposition1.p1.5.5.m5.1.1" xref="Thmproposition1.p1.5.5.m5.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="Thmproposition1.p1.5.5.m5.1b"><ci id="Thmproposition1.p1.5.5.m5.1.1.cmml" xref="Thmproposition1.p1.5.5.m5.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="Thmproposition1.p1.5.5.m5.1c">T</annotation><annotation encoding="application/x-llamapun" id="Thmproposition1.p1.5.5.m5.1d">italic_T</annotation></semantics></math> and any Bloom filter for the distinct <math alttext="k" class="ltx_Math" display="inline" id="Thmproposition1.p1.6.6.m6.1"><semantics id="Thmproposition1.p1.6.6.m6.1a"><mi id="Thmproposition1.p1.6.6.m6.1.1" xref="Thmproposition1.p1.6.6.m6.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="Thmproposition1.p1.6.6.m6.1b"><ci id="Thmproposition1.p1.6.6.m6.1.1.cmml" xref="Thmproposition1.p1.6.6.m6.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="Thmproposition1.p1.6.6.m6.1c">k</annotation><annotation encoding="application/x-llamapun" id="Thmproposition1.p1.6.6.m6.1d">italic_k</annotation></semantics></math>-mers in <math alttext="T" class="ltx_Math" display="inline" id="Thmproposition1.p1.7.7.m7.1"><semantics id="Thmproposition1.p1.7.7.m7.1a"><mi id="Thmproposition1.p1.7.7.m7.1.1" xref="Thmproposition1.p1.7.7.m7.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="Thmproposition1.p1.7.7.m7.1b"><ci id="Thmproposition1.p1.7.7.m7.1.1.cmml" xref="Thmproposition1.p1.7.7.m7.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="Thmproposition1.p1.7.7.m7.1c">T</annotation><annotation encoding="application/x-llamapun" id="Thmproposition1.p1.7.7.m7.1d">italic_T</annotation></semantics></math>.</span></p>
</div>
</div>
<div class="ltx_para" id="S3.p3">
<p class="ltx_p" id="S3.p3.2">Our experiments in Section <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4" title="4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">4</span></a> show that computing the pseudo-MEMs and searching in them is in practice already faster than searching in all of <math alttext="P" class="ltx_Math" display="inline" id="S3.p3.1.m1.1"><semantics id="S3.p3.1.m1.1a"><mi id="S3.p3.1.m1.1.1" xref="S3.p3.1.m1.1.1.cmml">P</mi><annotation-xml encoding="MathML-Content" id="S3.p3.1.m1.1b"><ci id="S3.p3.1.m1.1.1.cmml" xref="S3.p3.1.m1.1.1">𝑃</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p3.1.m1.1c">P</annotation><annotation encoding="application/x-llamapun" id="S3.p3.1.m1.1d">italic_P</annotation></semantics></math>. Further, they show that if <math alttext="T" class="ltx_Math" display="inline" id="S3.p3.2.m2.1"><semantics id="S3.p3.2.m2.1a"><mi id="S3.p3.2.m2.1.1" xref="S3.p3.2.m2.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S3.p3.2.m2.1b"><ci id="S3.p3.2.m2.1.1.cmml" xref="S3.p3.2.m2.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p3.2.m2.1c">T</annotation><annotation encoding="application/x-llamapun" id="S3.p3.2.m2.1d">italic_T</annotation></semantics></math> is highly repetitive then the Bloom filter tends to be smaller than the FM-indexes for <span class="ltx_text ltx_font_typewriter" id="S3.p3.2.1">ropebwt3</span>.</p>
</div>
<div class="ltx_para" id="S3.p4">
<p class="ltx_p" id="S3.p4.4">If we seek only the top-<math alttext="t" class="ltx_Math" display="inline" id="S3.p4.1.m1.1"><semantics id="S3.p4.1.m1.1a"><mi id="S3.p4.1.m1.1.1" xref="S3.p4.1.m1.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S3.p4.1.m1.1b"><ci id="S3.p4.1.m1.1.1.cmml" xref="S3.p4.1.m1.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p4.1.m1.1c">t</annotation><annotation encoding="application/x-llamapun" id="S3.p4.1.m1.1d">italic_t</annotation></semantics></math> longest MEMs of length at least <math alttext="L" class="ltx_Math" display="inline" id="S3.p4.2.m2.1"><semantics id="S3.p4.2.m2.1a"><mi id="S3.p4.2.m2.1.1" xref="S3.p4.2.m2.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="S3.p4.2.m2.1b"><ci id="S3.p4.2.m2.1.1.cmml" xref="S3.p4.2.m2.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p4.2.m2.1c">L</annotation><annotation encoding="application/x-llamapun" id="S3.p4.2.m2.1d">italic_L</annotation></semantics></math>, however, then we can search the pseudo-MEMs in non-increasing order by length and stop when we have found <math alttext="t" class="ltx_Math" display="inline" id="S3.p4.3.m3.1"><semantics id="S3.p4.3.m3.1a"><mi id="S3.p4.3.m3.1.1" xref="S3.p4.3.m3.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S3.p4.3.m3.1b"><ci id="S3.p4.3.m3.1.1.cmml" xref="S3.p4.3.m3.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p4.3.m3.1c">t</annotation><annotation encoding="application/x-llamapun" id="S3.p4.3.m3.1d">italic_t</annotation></semantics></math> MEMs at least as long as the next pseudo-MEM. We can compute and sort the pseudo-MEMs independently of the actual MEM-finding algorithm we are using, but having it keep track of <math alttext="t" class="ltx_Math" display="inline" id="S3.p4.4.m4.1"><semantics id="S3.p4.4.m4.1a"><mi id="S3.p4.4.m4.1.1" xref="S3.p4.4.m4.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S3.p4.4.m4.1b"><ci id="S3.p4.4.m4.1.1.cmml" xref="S3.p4.4.m4.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p4.4.m4.1c">t</annotation><annotation encoding="application/x-llamapun" id="S3.p4.4.m4.1d">italic_t</annotation></semantics></math> longest MEMs it has found and stop when the next pseudo-MEMs is shorter should require us to modify it. We have not yet done this for <span class="ltx_text ltx_font_typewriter" id="S3.p4.4.1">ropebwt3</span>.</p>
</div>
<div class="ltx_theorem ltx_theorem_proposition" id="Thmproposition2">
<h6 class="ltx_title ltx_font_bold ltx_title_theorem"><span class="ltx_tag ltx_tag_theorem">Proposition 2</span></h6>
<div class="ltx_para" id="Thmproposition2.p1">
<p class="ltx_p" id="Thmproposition2.p1.3"><span class="ltx_text ltx_font_italic" id="Thmproposition2.p1.3.3">If we seek only the top-<math alttext="t" class="ltx_Math" display="inline" id="Thmproposition2.p1.1.1.m1.1"><semantics id="Thmproposition2.p1.1.1.m1.1a"><mi id="Thmproposition2.p1.1.1.m1.1.1" xref="Thmproposition2.p1.1.1.m1.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="Thmproposition2.p1.1.1.m1.1b"><ci id="Thmproposition2.p1.1.1.m1.1.1.cmml" xref="Thmproposition2.p1.1.1.m1.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="Thmproposition2.p1.1.1.m1.1c">t</annotation><annotation encoding="application/x-llamapun" id="Thmproposition2.p1.1.1.m1.1d">italic_t</annotation></semantics></math> longest MEMs of length at least <math alttext="L" class="ltx_Math" display="inline" id="Thmproposition2.p1.2.2.m2.1"><semantics id="Thmproposition2.p1.2.2.m2.1a"><mi id="Thmproposition2.p1.2.2.m2.1.1" xref="Thmproposition2.p1.2.2.m2.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="Thmproposition2.p1.2.2.m2.1b"><ci id="Thmproposition2.p1.2.2.m2.1.1.cmml" xref="Thmproposition2.p1.2.2.m2.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="Thmproposition2.p1.2.2.m2.1c">L</annotation><annotation encoding="application/x-llamapun" id="Thmproposition2.p1.2.2.m2.1d">italic_L</annotation></semantics></math> and we are searching the pseudo-MEMs in non-increasing order by length, we can stop when we have already found <math alttext="t" class="ltx_Math" display="inline" id="Thmproposition2.p1.3.3.m3.1"><semantics id="Thmproposition2.p1.3.3.m3.1a"><mi id="Thmproposition2.p1.3.3.m3.1.1" xref="Thmproposition2.p1.3.3.m3.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="Thmproposition2.p1.3.3.m3.1b"><ci id="Thmproposition2.p1.3.3.m3.1.1.cmml" xref="Thmproposition2.p1.3.3.m3.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="Thmproposition2.p1.3.3.m3.1c">t</annotation><annotation encoding="application/x-llamapun" id="Thmproposition2.p1.3.3.m3.1d">italic_t</annotation></semantics></math> MEMs longer than the next pseudo-MEM.</span></p>
</div>
</div>
<div class="ltx_para" id="S3.p5">
<p class="ltx_p" id="S3.p5.4">Without modifying <span class="ltx_text ltx_font_typewriter" id="S3.p5.4.1">ropebwt3</span>, we can estimate how long it would take to find the top-<math alttext="t" class="ltx_Math" display="inline" id="S3.p5.1.m1.1"><semantics id="S3.p5.1.m1.1a"><mi id="S3.p5.1.m1.1.1" xref="S3.p5.1.m1.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S3.p5.1.m1.1b"><ci id="S3.p5.1.m1.1.1.cmml" xref="S3.p5.1.m1.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p5.1.m1.1c">t</annotation><annotation encoding="application/x-llamapun" id="S3.p5.1.m1.1d">italic_t</annotation></semantics></math> MEMs by finding them ourselves ahead of time and giving <span class="ltx_text ltx_font_typewriter" id="S3.p5.4.2">ropebwt3</span> only the pseudo-MEMs it would search in before stopping. Our experiments in Section <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4" title="4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">4</span></a> show that for reasonable values of <math alttext="t" class="ltx_Math" display="inline" id="S3.p5.2.m2.1"><semantics id="S3.p5.2.m2.1a"><mi id="S3.p5.2.m2.1.1" xref="S3.p5.2.m2.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S3.p5.2.m2.1b"><ci id="S3.p5.2.m2.1.1.cmml" xref="S3.p5.2.m2.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p5.2.m2.1c">t</annotation><annotation encoding="application/x-llamapun" id="S3.p5.2.m2.1d">italic_t</annotation></semantics></math>, this should be much faster than running <span class="ltx_text ltx_font_typewriter" id="S3.p5.4.3">ropebwt3</span> on all the pseudo-MEMs; moreover, at least for the metagenomic classifier we tested, it does not significantly hurt the accuracy. In fact, we found that using the long MEMs we found in only the top-<math alttext="t" class="ltx_Math" display="inline" id="S3.p5.3.m3.1"><semantics id="S3.p5.3.m3.1a"><mi id="S3.p5.3.m3.1.1" xref="S3.p5.3.m3.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S3.p5.3.m3.1b"><ci id="S3.p5.3.m3.1.1.cmml" xref="S3.p5.3.m3.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p5.3.m3.1c">t</annotation><annotation encoding="application/x-llamapun" id="S3.p5.3.m3.1d">italic_t</annotation></semantics></math> pseudo-MEMs — which are not guaranteed to be the top-<math alttext="t" class="ltx_Math" display="inline" id="S3.p5.4.m4.1"><semantics id="S3.p5.4.m4.1a"><mi id="S3.p5.4.m4.1.1" xref="S3.p5.4.m4.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S3.p5.4.m4.1b"><ci id="S3.p5.4.m4.1.1.cmml" xref="S3.p5.4.m4.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.p5.4.m4.1c">t</annotation><annotation encoding="application/x-llamapun" id="S3.p5.4.m4.1d">italic_t</annotation></semantics></math> MEMs but which we can find without modifying MEM-finders such as <span class="ltx_text ltx_font_typewriter" id="S3.p5.4.4">ropebwt3</span> — is even faster and still results in nearly identical classification accuracy.</p>
</div>
</section>
<section class="ltx_section" id="S4">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">4 </span>Experiments</h2>
<div class="ltx_para" id="S4.p1">
<p class="ltx_p" id="S4.p1.4">Our <span class="ltx_text ltx_font_typewriter" id="S4.p1.4.1">kebab</span> implementation in <span class="ltx_text ltx_font_typewriter" id="S4.p1.4.2">C++</span> is available at <span class="ltx_ref ltx_nolink ltx_url ltx_font_typewriter ltx_ref_self">github.com/drnatebrown/kebab</span>. It streams over <math alttext="k" class="ltx_Math" display="inline" id="S4.p1.1.m1.1"><semantics id="S4.p1.1.m1.1a"><mi id="S4.p1.1.m1.1.1" xref="S4.p1.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S4.p1.1.m1.1b"><ci id="S4.p1.1.m1.1.1.cmml" xref="S4.p1.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.p1.1.m1.1c">k</annotation><annotation encoding="application/x-llamapun" id="S4.p1.1.m1.1d">italic_k</annotation></semantics></math>-mers using a rolling nucleotide hash defined by ntHash supporting both forward and reverse complement <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib11" title="">11</a>]</cite>. We use HyperLogLog <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib7" title="">7</a>]</cite> to estimate the cardinality of a text collection to initialize the Bloom filter size, which is optimized with respect to the number of filter hashes used. We then add canonical <math alttext="k" class="ltx_Math" display="inline" id="S4.p1.2.m2.1"><semantics id="S4.p1.2.m2.1a"><mi id="S4.p1.2.m2.1.1" xref="S4.p1.2.m2.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S4.p1.2.m2.1b"><ci id="S4.p1.2.m2.1.1.cmml" xref="S4.p1.2.m2.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.p1.2.m2.1c">k</annotation><annotation encoding="application/x-llamapun" id="S4.p1.2.m2.1d">italic_k</annotation></semantics></math>-mers (the smaller of each <math alttext="k" class="ltx_Math" display="inline" id="S4.p1.3.m3.1"><semantics id="S4.p1.3.m3.1a"><mi id="S4.p1.3.m3.1.1" xref="S4.p1.3.m3.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S4.p1.3.m3.1b"><ci id="S4.p1.3.m3.1.1.cmml" xref="S4.p1.3.m3.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.p1.3.m3.1c">k</annotation><annotation encoding="application/x-llamapun" id="S4.p1.3.m3.1d">italic_k</annotation></semantics></math>-mer and its reverse complement by hash value) to the filter. Given a pattern, we query its canonical <math alttext="k" class="ltx_Math" display="inline" id="S4.p1.4.m4.1"><semantics id="S4.p1.4.m4.1a"><mi id="S4.p1.4.m4.1.1" xref="S4.p1.4.m4.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S4.p1.4.m4.1b"><ci id="S4.p1.4.m4.1.1.cmml" xref="S4.p1.4.m4.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.p1.4.m4.1c">k</annotation><annotation encoding="application/x-llamapun" id="S4.p1.4.m4.1d">italic_k</annotation></semantics></math>-mers and extract the pseudo-MEMs. We leave optimization details to the appendix.</p>
</div>
<section class="ltx_subsection" id="S4.SS1">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.1 </span>MEM-finding</h3>
<div class="ltx_para" id="S4.SS1.p1">
<p class="ltx_p" id="S4.SS1.p1.9">We tested the speed of MEM-finding on a mock community dataset of 7 microbial species (<math alttext="5867" class="ltx_Math" display="inline" id="S4.SS1.p1.1.m1.1"><semantics id="S4.SS1.p1.1.m1.1a"><mn id="S4.SS1.p1.1.m1.1.1" xref="S4.SS1.p1.1.m1.1.1.cmml">5867</mn><annotation-xml encoding="MathML-Content" id="S4.SS1.p1.1.m1.1b"><cn id="S4.SS1.p1.1.m1.1.1.cmml" type="integer" xref="S4.SS1.p1.1.m1.1.1">5867</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p1.1.m1.1c">5867</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p1.1.m1.1d">5867</annotation></semantics></math> genomes, <math alttext="\sim\!27" class="ltx_Math" display="inline" id="S4.SS1.p1.2.m2.1"><semantics id="S4.SS1.p1.2.m2.1a"><mrow id="S4.SS1.p1.2.m2.1.1" xref="S4.SS1.p1.2.m2.1.1.cmml"><mi id="S4.SS1.p1.2.m2.1.1.2" xref="S4.SS1.p1.2.m2.1.1.2.cmml"></mi><mo id="S4.SS1.p1.2.m2.1.1.1" rspace="0.108em" xref="S4.SS1.p1.2.m2.1.1.1.cmml">∼</mo><mn id="S4.SS1.p1.2.m2.1.1.3" xref="S4.SS1.p1.2.m2.1.1.3.cmml">27</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS1.p1.2.m2.1b"><apply id="S4.SS1.p1.2.m2.1.1.cmml" xref="S4.SS1.p1.2.m2.1.1"><csymbol cd="latexml" id="S4.SS1.p1.2.m2.1.1.1.cmml" xref="S4.SS1.p1.2.m2.1.1.1">similar-to</csymbol><csymbol cd="latexml" id="S4.SS1.p1.2.m2.1.1.2.cmml" xref="S4.SS1.p1.2.m2.1.1.2">absent</csymbol><cn id="S4.SS1.p1.2.m2.1.1.3.cmml" type="integer" xref="S4.SS1.p1.2.m2.1.1.3">27</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p1.2.m2.1c">\sim\!27</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p1.2.m2.1d">∼ 27</annotation></semantics></math> GB) from Ahmed et al.’s <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib1" title="">1</a>]</cite> SPUMONI 2 study. Patterns consist of long ONT <span class="ltx_text ltx_font_italic" id="S4.SS1.p1.9.1">null reads</span> (10245 yeast reads with average length <math alttext="19693" class="ltx_Math" display="inline" id="S4.SS1.p1.3.m3.1"><semantics id="S4.SS1.p1.3.m3.1a"><mn id="S4.SS1.p1.3.m3.1.1" xref="S4.SS1.p1.3.m3.1.1.cmml">19693</mn><annotation-xml encoding="MathML-Content" id="S4.SS1.p1.3.m3.1b"><cn id="S4.SS1.p1.3.m3.1.1.cmml" type="integer" xref="S4.SS1.p1.3.m3.1.1">19693</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p1.3.m3.1c">19693</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p1.3.m3.1d">19693</annotation></semantics></math>) and <span class="ltx_text ltx_font_italic" id="S4.SS1.p1.9.2">positive reads</span> (581802 microbial reads with average length <math alttext="25378" class="ltx_Math" display="inline" id="S4.SS1.p1.4.m4.1"><semantics id="S4.SS1.p1.4.m4.1a"><mn id="S4.SS1.p1.4.m4.1.1" xref="S4.SS1.p1.4.m4.1.1.cmml">25378</mn><annotation-xml encoding="MathML-Content" id="S4.SS1.p1.4.m4.1b"><cn id="S4.SS1.p1.4.m4.1.1.cmml" type="integer" xref="S4.SS1.p1.4.m4.1.1">25378</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p1.4.m4.1c">25378</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p1.4.m4.1d">25378</annotation></semantics></math>). Constructing <span class="ltx_text ltx_font_typewriter" id="S4.SS1.p1.9.3">ropebwt3</span> took <math alttext="162.88" class="ltx_Math" display="inline" id="S4.SS1.p1.5.m5.1"><semantics id="S4.SS1.p1.5.m5.1a"><mn id="S4.SS1.p1.5.m5.1.1" xref="S4.SS1.p1.5.m5.1.1.cmml">162.88</mn><annotation-xml encoding="MathML-Content" id="S4.SS1.p1.5.m5.1b"><cn id="S4.SS1.p1.5.m5.1.1.cmml" type="float" xref="S4.SS1.p1.5.m5.1.1">162.88</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p1.5.m5.1c">162.88</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p1.5.m5.1d">162.88</annotation></semantics></math> minutes with an <math alttext="0.7988" class="ltx_Math" display="inline" id="S4.SS1.p1.6.m6.1"><semantics id="S4.SS1.p1.6.m6.1a"><mn id="S4.SS1.p1.6.m6.1.1" xref="S4.SS1.p1.6.m6.1.1.cmml">0.7988</mn><annotation-xml encoding="MathML-Content" id="S4.SS1.p1.6.m6.1b"><cn id="S4.SS1.p1.6.m6.1.1.cmml" type="float" xref="S4.SS1.p1.6.m6.1.1">0.7988</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p1.6.m6.1c">0.7988</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p1.6.m6.1d">0.7988</annotation></semantics></math> GB index. Building <span class="ltx_text ltx_font_typewriter" id="S4.SS1.p1.9.4">kebab</span> with <math alttext="k=20" class="ltx_Math" display="inline" id="S4.SS1.p1.7.m7.1"><semantics id="S4.SS1.p1.7.m7.1a"><mrow id="S4.SS1.p1.7.m7.1.1" xref="S4.SS1.p1.7.m7.1.1.cmml"><mi id="S4.SS1.p1.7.m7.1.1.2" xref="S4.SS1.p1.7.m7.1.1.2.cmml">k</mi><mo id="S4.SS1.p1.7.m7.1.1.1" xref="S4.SS1.p1.7.m7.1.1.1.cmml">=</mo><mn id="S4.SS1.p1.7.m7.1.1.3" xref="S4.SS1.p1.7.m7.1.1.3.cmml">20</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS1.p1.7.m7.1b"><apply id="S4.SS1.p1.7.m7.1.1.cmml" xref="S4.SS1.p1.7.m7.1.1"><eq id="S4.SS1.p1.7.m7.1.1.1.cmml" xref="S4.SS1.p1.7.m7.1.1.1"></eq><ci id="S4.SS1.p1.7.m7.1.1.2.cmml" xref="S4.SS1.p1.7.m7.1.1.2">𝑘</ci><cn id="S4.SS1.p1.7.m7.1.1.3.cmml" type="integer" xref="S4.SS1.p1.7.m7.1.1.3">20</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p1.7.m7.1c">k=20</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p1.7.m7.1d">italic_k = 20</annotation></semantics></math> and one hash function took <math alttext="4.02" class="ltx_Math" display="inline" id="S4.SS1.p1.8.m8.1"><semantics id="S4.SS1.p1.8.m8.1a"><mn id="S4.SS1.p1.8.m8.1.1" xref="S4.SS1.p1.8.m8.1.1.cmml">4.02</mn><annotation-xml encoding="MathML-Content" id="S4.SS1.p1.8.m8.1b"><cn id="S4.SS1.p1.8.m8.1.1.cmml" type="float" xref="S4.SS1.p1.8.m8.1.1">4.02</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p1.8.m8.1c">4.02</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p1.8.m8.1d">4.02</annotation></semantics></math> minutes with an <math alttext="0.2684" class="ltx_Math" display="inline" id="S4.SS1.p1.9.m9.1"><semantics id="S4.SS1.p1.9.m9.1a"><mn id="S4.SS1.p1.9.m9.1.1" xref="S4.SS1.p1.9.m9.1.1.cmml">0.2684</mn><annotation-xml encoding="MathML-Content" id="S4.SS1.p1.9.m9.1b"><cn id="S4.SS1.p1.9.m9.1.1.cmml" type="float" xref="S4.SS1.p1.9.m9.1.1">0.2684</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p1.9.m9.1c">0.2684</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p1.9.m9.1d">0.2684</annotation></semantics></math> GB filter (about a third of the size of <span class="ltx_text ltx_font_typewriter" id="S4.SS1.p1.9.5">ropebwt3</span>’s index).</p>
</div>
<div class="ltx_para" id="S4.SS1.p2">
<p class="ltx_p" id="S4.SS1.p2.3">We compared the time to find MEMs with <span class="ltx_text ltx_font_typewriter" id="S4.SS1.p2.3.1">ropebwt3</span> alone with default settings, to the time to first generate pseudo-MEMs with <span class="ltx_text ltx_font_typewriter" id="S4.SS1.p2.3.2">kebab</span> and then search them with <span class="ltx_text ltx_font_typewriter" id="S4.SS1.p2.3.3">ropebwt3</span>. We also simulated early stopping to find the 10 longest MEMs as explained in Section <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S3" title="3 𝑘-mer based breaking into pseudo-MEMs ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">3</span></a>.
Figure <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4.F2" title="Figure 2 ‣ 4.1 MEM-finding ‣ 4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">2</span></a> shows the total times for different choices of <math alttext="L" class="ltx_Math" display="inline" id="S4.SS1.p2.1.m1.1"><semantics id="S4.SS1.p2.1.m1.1a"><mi id="S4.SS1.p2.1.m1.1.1" xref="S4.SS1.p2.1.m1.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="S4.SS1.p2.1.m1.1b"><ci id="S4.SS1.p2.1.m1.1.1.cmml" xref="S4.SS1.p2.1.m1.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p2.1.m1.1c">L</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p2.1.m1.1d">italic_L</annotation></semantics></math>, and Figure <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4.F3" title="Figure 3 ‣ 4.1 MEM-finding ‣ 4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">3</span></a> shows times for null and positive reads with <math alttext="L=40" class="ltx_Math" display="inline" id="S4.SS1.p2.2.m2.1"><semantics id="S4.SS1.p2.2.m2.1a"><mrow id="S4.SS1.p2.2.m2.1.1" xref="S4.SS1.p2.2.m2.1.1.cmml"><mi id="S4.SS1.p2.2.m2.1.1.2" xref="S4.SS1.p2.2.m2.1.1.2.cmml">L</mi><mo id="S4.SS1.p2.2.m2.1.1.1" xref="S4.SS1.p2.2.m2.1.1.1.cmml">=</mo><mn id="S4.SS1.p2.2.m2.1.1.3" xref="S4.SS1.p2.2.m2.1.1.3.cmml">40</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS1.p2.2.m2.1b"><apply id="S4.SS1.p2.2.m2.1.1.cmml" xref="S4.SS1.p2.2.m2.1.1"><eq id="S4.SS1.p2.2.m2.1.1.1.cmml" xref="S4.SS1.p2.2.m2.1.1.1"></eq><ci id="S4.SS1.p2.2.m2.1.1.2.cmml" xref="S4.SS1.p2.2.m2.1.1.2">𝐿</ci><cn id="S4.SS1.p2.2.m2.1.1.3.cmml" type="integer" xref="S4.SS1.p2.2.m2.1.1.3">40</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p2.2.m2.1c">L=40</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p2.2.m2.1d">italic_L = 40</annotation></semantics></math>. For <math alttext="L\geq 30" class="ltx_Math" display="inline" id="S4.SS1.p2.3.m3.1"><semantics id="S4.SS1.p2.3.m3.1a"><mrow id="S4.SS1.p2.3.m3.1.1" xref="S4.SS1.p2.3.m3.1.1.cmml"><mi id="S4.SS1.p2.3.m3.1.1.2" xref="S4.SS1.p2.3.m3.1.1.2.cmml">L</mi><mo id="S4.SS1.p2.3.m3.1.1.1" xref="S4.SS1.p2.3.m3.1.1.1.cmml">≥</mo><mn id="S4.SS1.p2.3.m3.1.1.3" xref="S4.SS1.p2.3.m3.1.1.3.cmml">30</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS1.p2.3.m3.1b"><apply id="S4.SS1.p2.3.m3.1.1.cmml" xref="S4.SS1.p2.3.m3.1.1"><geq id="S4.SS1.p2.3.m3.1.1.1.cmml" xref="S4.SS1.p2.3.m3.1.1.1"></geq><ci id="S4.SS1.p2.3.m3.1.1.2.cmml" xref="S4.SS1.p2.3.m3.1.1.2">𝐿</ci><cn id="S4.SS1.p2.3.m3.1.1.3.cmml" type="integer" xref="S4.SS1.p2.3.m3.1.1.3">30</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p2.3.m3.1c">L\geq 30</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p2.3.m3.1d">italic_L ≥ 30</annotation></semantics></math>, the running-time of only the <span class="ltx_text ltx_font_typewriter" id="S4.SS1.p2.3.4">kebab</span> step on the reads was at most about 3 times more than the time to copy them to another file, which is a rough lower bound on file I/O for a filtering step.</p>
</div>
<figure class="ltx_figure" id="S4.F2"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="156" id="S4.F2.g1" src="x2.png" width="747"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 2: </span>Total runtime in seconds for MEM-finding methods, searching in a microbial pangenome with different minimum MEM-length values <math alttext="L" class="ltx_Math" display="inline" id="S4.F2.2.m1.1"><semantics id="S4.F2.2.m1.1b"><mi id="S4.F2.2.m1.1.1" xref="S4.F2.2.m1.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="S4.F2.2.m1.1c"><ci id="S4.F2.2.m1.1.1.cmml" xref="S4.F2.2.m1.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.F2.2.m1.1d">L</annotation><annotation encoding="application/x-llamapun" id="S4.F2.2.m1.1e">italic_L</annotation></semantics></math>.</figcaption>
</figure>
<figure class="ltx_figure" id="S4.F3"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="249" id="S4.F3.g1" src="x3.png" width="747"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 3: </span>For <math alttext="L=40" class="ltx_Math" display="inline" id="S4.F3.2.m1.1"><semantics id="S4.F3.2.m1.1b"><mrow id="S4.F3.2.m1.1.1" xref="S4.F3.2.m1.1.1.cmml"><mi id="S4.F3.2.m1.1.1.2" xref="S4.F3.2.m1.1.1.2.cmml">L</mi><mo id="S4.F3.2.m1.1.1.1" xref="S4.F3.2.m1.1.1.1.cmml">=</mo><mn id="S4.F3.2.m1.1.1.3" xref="S4.F3.2.m1.1.1.3.cmml">40</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.F3.2.m1.1c"><apply id="S4.F3.2.m1.1.1.cmml" xref="S4.F3.2.m1.1.1"><eq id="S4.F3.2.m1.1.1.1.cmml" xref="S4.F3.2.m1.1.1.1"></eq><ci id="S4.F3.2.m1.1.1.2.cmml" xref="S4.F3.2.m1.1.1.2">𝐿</ci><cn id="S4.F3.2.m1.1.1.3.cmml" type="integer" xref="S4.F3.2.m1.1.1.3">40</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.F3.2.m1.1d">L=40</annotation><annotation encoding="application/x-llamapun" id="S4.F3.2.m1.1e">italic_L = 40</annotation></semantics></math>, time per base to find all long MEMs or only the 10 longest MEMs.</figcaption>
</figure>
</section>
<section class="ltx_subsection" id="S4.SS2">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.2 </span>Metagenomic Classification</h3>
<div class="ltx_para" id="S4.SS2.p1">
<p class="ltx_p" id="S4.SS2.p1.4">To see how using only a few long MEMs affects downstream applications, we replicated the metagenomic classification experiment in Depuydt et al.’s <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib5" title="">5</a>]</cite> <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p1.4.1">tagger</span> study, consisting of 8 microbial species (<math alttext="8165" class="ltx_Math" display="inline" id="S4.SS2.p1.1.m1.1"><semantics id="S4.SS2.p1.1.m1.1a"><mn id="S4.SS2.p1.1.m1.1.1" xref="S4.SS2.p1.1.m1.1.1.cmml">8165</mn><annotation-xml encoding="MathML-Content" id="S4.SS2.p1.1.m1.1b"><cn id="S4.SS2.p1.1.m1.1.1.cmml" type="integer" xref="S4.SS2.p1.1.m1.1.1">8165</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p1.1.m1.1c">8165</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p1.1.m1.1d">8165</annotation></semantics></math> genomes, <math alttext="\sim\!37" class="ltx_Math" display="inline" id="S4.SS2.p1.2.m2.1"><semantics id="S4.SS2.p1.2.m2.1a"><mrow id="S4.SS2.p1.2.m2.1.1" xref="S4.SS2.p1.2.m2.1.1.cmml"><mi id="S4.SS2.p1.2.m2.1.1.2" xref="S4.SS2.p1.2.m2.1.1.2.cmml"></mi><mo id="S4.SS2.p1.2.m2.1.1.1" rspace="0.108em" xref="S4.SS2.p1.2.m2.1.1.1.cmml">∼</mo><mn id="S4.SS2.p1.2.m2.1.1.3" xref="S4.SS2.p1.2.m2.1.1.3.cmml">37</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS2.p1.2.m2.1b"><apply id="S4.SS2.p1.2.m2.1.1.cmml" xref="S4.SS2.p1.2.m2.1.1"><csymbol cd="latexml" id="S4.SS2.p1.2.m2.1.1.1.cmml" xref="S4.SS2.p1.2.m2.1.1.1">similar-to</csymbol><csymbol cd="latexml" id="S4.SS2.p1.2.m2.1.1.2.cmml" xref="S4.SS2.p1.2.m2.1.1.2">absent</csymbol><cn id="S4.SS2.p1.2.m2.1.1.3.cmml" type="integer" xref="S4.SS2.p1.2.m2.1.1.3">37</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p1.2.m2.1c">\sim\!37</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p1.2.m2.1d">∼ 37</annotation></semantics></math>GB) and <math alttext="50000" class="ltx_Math" display="inline" id="S4.SS2.p1.3.m3.1"><semantics id="S4.SS2.p1.3.m3.1a"><mn id="S4.SS2.p1.3.m3.1.1" xref="S4.SS2.p1.3.m3.1.1.cmml">50000</mn><annotation-xml encoding="MathML-Content" id="S4.SS2.p1.3.m3.1b"><cn id="S4.SS2.p1.3.m3.1.1.cmml" type="integer" xref="S4.SS2.p1.3.m3.1.1">50000</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p1.3.m3.1c">50000</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p1.3.m3.1d">50000</annotation></semantics></math> simulated long ONT reads with average length <math alttext="5236" class="ltx_Math" display="inline" id="S4.SS2.p1.4.m4.1"><semantics id="S4.SS2.p1.4.m4.1a"><mn id="S4.SS2.p1.4.m4.1.1" xref="S4.SS2.p1.4.m4.1.1.cmml">5236</mn><annotation-xml encoding="MathML-Content" id="S4.SS2.p1.4.m4.1b"><cn id="S4.SS2.p1.4.m4.1.1.cmml" type="integer" xref="S4.SS2.p1.4.m4.1.1">5236</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p1.4.m4.1c">5236</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p1.4.m4.1d">5236</annotation></semantics></math>. By default, <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p1.4.2">tagger</span> uses Depuydt et al.’s <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib4" title="">4</a>]</cite> bidirectional r-index <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p1.4.3">b-move</span> with BML to find long MEMs together with sample species containing occurrences of them, then classifies the reads based on the sample species containing each read’s long MEMs. We note that <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p1.4.4">b-move</span> is usually larger but faster than <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p1.4.5">ropebwt3</span>, so speedups with <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p1.4.6">kebab</span> are not as dramatic.</p>
</div>
<div class="ltx_para" id="S4.SS2.p2">
<p class="ltx_p" id="S4.SS2.p2.8">We computed <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p2.8.1">tagger</span>’s accuracies (on the left) — that is, its percentages of true-positive classifications — and the average number of steps <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p2.8.2">b-move</span> takes (on the right) when finding and classifying based on</p>
<ul class="ltx_itemize" id="S4.I1">
<li class="ltx_item" id="S4.I1.i1" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S4.I1.i1.p1">
<p class="ltx_p" id="S4.I1.i1.p1.1">all the reads’ MEMs of length at least <math alttext="L" class="ltx_Math" display="inline" id="S4.I1.i1.p1.1.m1.1"><semantics id="S4.I1.i1.p1.1.m1.1a"><mi id="S4.I1.i1.p1.1.m1.1.1" xref="S4.I1.i1.p1.1.m1.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="S4.I1.i1.p1.1.m1.1b"><ci id="S4.I1.i1.p1.1.m1.1.1.cmml" xref="S4.I1.i1.p1.1.m1.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.i1.p1.1.m1.1c">L</annotation><annotation encoding="application/x-llamapun" id="S4.I1.i1.p1.1.m1.1d">italic_L</annotation></semantics></math> (“default”),</p>
</div>
</li>
<li class="ltx_item" id="S4.I1.i2" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S4.I1.i2.p1">
<p class="ltx_p" id="S4.I1.i2.p1.2">only the longest <math alttext="t" class="ltx_Math" display="inline" id="S4.I1.i2.p1.1.m1.1"><semantics id="S4.I1.i2.p1.1.m1.1a"><mi id="S4.I1.i2.p1.1.m1.1.1" xref="S4.I1.i2.p1.1.m1.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S4.I1.i2.p1.1.m1.1b"><ci id="S4.I1.i2.p1.1.m1.1.1.cmml" xref="S4.I1.i2.p1.1.m1.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.i2.p1.1.m1.1c">t</annotation><annotation encoding="application/x-llamapun" id="S4.I1.i2.p1.1.m1.1d">italic_t</annotation></semantics></math> MEMs from each read (“top-<math alttext="t" class="ltx_Math" display="inline" id="S4.I1.i2.p1.2.m2.1"><semantics id="S4.I1.i2.p1.2.m2.1a"><mi id="S4.I1.i2.p1.2.m2.1.1" xref="S4.I1.i2.p1.2.m2.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S4.I1.i2.p1.2.m2.1b"><ci id="S4.I1.i2.p1.2.m2.1.1.cmml" xref="S4.I1.i2.p1.2.m2.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.i2.p1.2.m2.1c">t</annotation><annotation encoding="application/x-llamapun" id="S4.I1.i2.p1.2.m2.1d">italic_t</annotation></semantics></math> MEMs”),</p>
</div>
</li>
<li class="ltx_item" id="S4.I1.i3" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S4.I1.i3.p1">
<p class="ltx_p" id="S4.I1.i3.p1.3">only the MEMs of length at least <math alttext="L" class="ltx_Math" display="inline" id="S4.I1.i3.p1.1.m1.1"><semantics id="S4.I1.i3.p1.1.m1.1a"><mi id="S4.I1.i3.p1.1.m1.1.1" xref="S4.I1.i3.p1.1.m1.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="S4.I1.i3.p1.1.m1.1b"><ci id="S4.I1.i3.p1.1.m1.1.1.cmml" xref="S4.I1.i3.p1.1.m1.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.i3.p1.1.m1.1c">L</annotation><annotation encoding="application/x-llamapun" id="S4.I1.i3.p1.1.m1.1d">italic_L</annotation></semantics></math> in the longest <math alttext="t" class="ltx_Math" display="inline" id="S4.I1.i3.p1.2.m2.1"><semantics id="S4.I1.i3.p1.2.m2.1a"><mi id="S4.I1.i3.p1.2.m2.1.1" xref="S4.I1.i3.p1.2.m2.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S4.I1.i3.p1.2.m2.1b"><ci id="S4.I1.i3.p1.2.m2.1.1.cmml" xref="S4.I1.i3.p1.2.m2.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.i3.p1.2.m2.1c">t</annotation><annotation encoding="application/x-llamapun" id="S4.I1.i3.p1.2.m2.1d">italic_t</annotation></semantics></math> pseudo-MEMs from each read (“top-<math alttext="t" class="ltx_Math" display="inline" id="S4.I1.i3.p1.3.m3.1"><semantics id="S4.I1.i3.p1.3.m3.1a"><mi id="S4.I1.i3.p1.3.m3.1.1" xref="S4.I1.i3.p1.3.m3.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S4.I1.i3.p1.3.m3.1b"><ci id="S4.I1.i3.p1.3.m3.1.1.cmml" xref="S4.I1.i3.p1.3.m3.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.i3.p1.3.m3.1c">t</annotation><annotation encoding="application/x-llamapun" id="S4.I1.i3.p1.3.m3.1d">italic_t</annotation></semantics></math> pseudo-MEMs”),</p>
</div>
</li>
</ul>
<p class="ltx_p" id="S4.SS2.p2.7">for <math alttext="L=25" class="ltx_Math" display="inline" id="S4.SS2.p2.1.m1.1"><semantics id="S4.SS2.p2.1.m1.1a"><mrow id="S4.SS2.p2.1.m1.1.1" xref="S4.SS2.p2.1.m1.1.1.cmml"><mi id="S4.SS2.p2.1.m1.1.1.2" xref="S4.SS2.p2.1.m1.1.1.2.cmml">L</mi><mo id="S4.SS2.p2.1.m1.1.1.1" xref="S4.SS2.p2.1.m1.1.1.1.cmml">=</mo><mn id="S4.SS2.p2.1.m1.1.1.3" xref="S4.SS2.p2.1.m1.1.1.3.cmml">25</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS2.p2.1.m1.1b"><apply id="S4.SS2.p2.1.m1.1.1.cmml" xref="S4.SS2.p2.1.m1.1.1"><eq id="S4.SS2.p2.1.m1.1.1.1.cmml" xref="S4.SS2.p2.1.m1.1.1.1"></eq><ci id="S4.SS2.p2.1.m1.1.1.2.cmml" xref="S4.SS2.p2.1.m1.1.1.2">𝐿</ci><cn id="S4.SS2.p2.1.m1.1.1.3.cmml" type="integer" xref="S4.SS2.p2.1.m1.1.1.3">25</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p2.1.m1.1c">L=25</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p2.1.m1.1d">italic_L = 25</annotation></semantics></math> and various values of <math alttext="t" class="ltx_Math" display="inline" id="S4.SS2.p2.2.m2.1"><semantics id="S4.SS2.p2.2.m2.1a"><mi id="S4.SS2.p2.2.m2.1.1" xref="S4.SS2.p2.2.m2.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S4.SS2.p2.2.m2.1b"><ci id="S4.SS2.p2.2.m2.1.1.cmml" xref="S4.SS2.p2.2.m2.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p2.2.m2.1c">t</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p2.2.m2.1d">italic_t</annotation></semantics></math>. We ran <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p2.7.1">tagger</span> with default settings and <math alttext="L=25" class="ltx_Math" display="inline" id="S4.SS2.p2.3.m3.1"><semantics id="S4.SS2.p2.3.m3.1a"><mrow id="S4.SS2.p2.3.m3.1.1" xref="S4.SS2.p2.3.m3.1.1.cmml"><mi id="S4.SS2.p2.3.m3.1.1.2" xref="S4.SS2.p2.3.m3.1.1.2.cmml">L</mi><mo id="S4.SS2.p2.3.m3.1.1.1" xref="S4.SS2.p2.3.m3.1.1.1.cmml">=</mo><mn id="S4.SS2.p2.3.m3.1.1.3" xref="S4.SS2.p2.3.m3.1.1.3.cmml">25</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS2.p2.3.m3.1b"><apply id="S4.SS2.p2.3.m3.1.1.cmml" xref="S4.SS2.p2.3.m3.1.1"><eq id="S4.SS2.p2.3.m3.1.1.1.cmml" xref="S4.SS2.p2.3.m3.1.1.1"></eq><ci id="S4.SS2.p2.3.m3.1.1.2.cmml" xref="S4.SS2.p2.3.m3.1.1.2">𝐿</ci><cn id="S4.SS2.p2.3.m3.1.1.3.cmml" type="integer" xref="S4.SS2.p2.3.m3.1.1.3">25</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p2.3.m3.1c">L=25</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p2.3.m3.1d">italic_L = 25</annotation></semantics></math> because Depuydt et al. found it gave good results. Clearly, for <math alttext="t" class="ltx_Math" display="inline" id="S4.SS2.p2.4.m4.1"><semantics id="S4.SS2.p2.4.m4.1a"><mi id="S4.SS2.p2.4.m4.1.1" xref="S4.SS2.p2.4.m4.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S4.SS2.p2.4.m4.1b"><ci id="S4.SS2.p2.4.m4.1.1.cmml" xref="S4.SS2.p2.4.m4.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p2.4.m4.1c">t</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p2.4.m4.1d">italic_t</annotation></semantics></math> greater than about 10, using only the <math alttext="t" class="ltx_Math" display="inline" id="S4.SS2.p2.5.m5.1"><semantics id="S4.SS2.p2.5.m5.1a"><mi id="S4.SS2.p2.5.m5.1.1" xref="S4.SS2.p2.5.m5.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S4.SS2.p2.5.m5.1b"><ci id="S4.SS2.p2.5.m5.1.1.cmml" xref="S4.SS2.p2.5.m5.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p2.5.m5.1c">t</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p2.5.m5.1d">italic_t</annotation></semantics></math> longest MEMs in each read or the MEMs of length at least <math alttext="L=25" class="ltx_Math" display="inline" id="S4.SS2.p2.6.m6.1"><semantics id="S4.SS2.p2.6.m6.1a"><mrow id="S4.SS2.p2.6.m6.1.1" xref="S4.SS2.p2.6.m6.1.1.cmml"><mi id="S4.SS2.p2.6.m6.1.1.2" xref="S4.SS2.p2.6.m6.1.1.2.cmml">L</mi><mo id="S4.SS2.p2.6.m6.1.1.1" xref="S4.SS2.p2.6.m6.1.1.1.cmml">=</mo><mn id="S4.SS2.p2.6.m6.1.1.3" xref="S4.SS2.p2.6.m6.1.1.3.cmml">25</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS2.p2.6.m6.1b"><apply id="S4.SS2.p2.6.m6.1.1.cmml" xref="S4.SS2.p2.6.m6.1.1"><eq id="S4.SS2.p2.6.m6.1.1.1.cmml" xref="S4.SS2.p2.6.m6.1.1.1"></eq><ci id="S4.SS2.p2.6.m6.1.1.2.cmml" xref="S4.SS2.p2.6.m6.1.1.2">𝐿</ci><cn id="S4.SS2.p2.6.m6.1.1.3.cmml" type="integer" xref="S4.SS2.p2.6.m6.1.1.3">25</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p2.6.m6.1c">L=25</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p2.6.m6.1d">italic_L = 25</annotation></semantics></math> in the <math alttext="t" class="ltx_Math" display="inline" id="S4.SS2.p2.7.m7.1"><semantics id="S4.SS2.p2.7.m7.1a"><mi id="S4.SS2.p2.7.m7.1.1" xref="S4.SS2.p2.7.m7.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S4.SS2.p2.7.m7.1b"><ci id="S4.SS2.p2.7.m7.1.1.cmml" xref="S4.SS2.p2.7.m7.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p2.7.m7.1c">t</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p2.7.m7.1d">italic_t</annotation></semantics></math> longest pseudo-MEMs, does not noticeably hurt <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p2.7.2">tagger</span>’s accuracy but significantly reduces the number of steps <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p2.7.3">b-move</span> takes for MEM-finding.</p>
</div>
<figure class="ltx_figure" id="S4.F4"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="173" id="S4.F4.g1" src="x4.png" width="830"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 4: </span><span class="ltx_text ltx_font_typewriter" id="S4.F4.5.1">tagger</span>’s accuracy <span class="ltx_text ltx_font_bold" id="S4.F4.6.2">(left)</span> and the average number of steps <span class="ltx_text ltx_font_typewriter" id="S4.F4.7.3">b-move</span> takes <span class="ltx_text ltx_font_bold" id="S4.F4.8.4">(right)</span> for MEM-finding.</figcaption>
</figure>
<figure class="ltx_figure" id="S4.F5"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="277" id="S4.F5.g1" src="x5.png" width="830"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 5: </span>The time to classify using the MEMs of length at least <math alttext="L=25" class="ltx_Math" display="inline" id="S4.F5.4.m1.1"><semantics id="S4.F5.4.m1.1b"><mrow id="S4.F5.4.m1.1.1" xref="S4.F5.4.m1.1.1.cmml"><mi id="S4.F5.4.m1.1.1.2" xref="S4.F5.4.m1.1.1.2.cmml">L</mi><mo id="S4.F5.4.m1.1.1.1" xref="S4.F5.4.m1.1.1.1.cmml">=</mo><mn id="S4.F5.4.m1.1.1.3" xref="S4.F5.4.m1.1.1.3.cmml">25</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.F5.4.m1.1c"><apply id="S4.F5.4.m1.1.1.cmml" xref="S4.F5.4.m1.1.1"><eq id="S4.F5.4.m1.1.1.1.cmml" xref="S4.F5.4.m1.1.1.1"></eq><ci id="S4.F5.4.m1.1.1.2.cmml" xref="S4.F5.4.m1.1.1.2">𝐿</ci><cn id="S4.F5.4.m1.1.1.3.cmml" type="integer" xref="S4.F5.4.m1.1.1.3">25</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.F5.4.m1.1d">L=25</annotation><annotation encoding="application/x-llamapun" id="S4.F5.4.m1.1e">italic_L = 25</annotation></semantics></math> using only <span class="ltx_text ltx_font_typewriter" id="S4.F5.12.1">tagger</span>, or <span class="ltx_text ltx_font_typewriter" id="S4.F5.13.2">kebab</span> followed by <span class="ltx_text ltx_font_typewriter" id="S4.F5.14.3">tagger</span>, or all the MEMs of length at least <math alttext="L=25" class="ltx_Math" display="inline" id="S4.F5.5.m2.1"><semantics id="S4.F5.5.m2.1b"><mrow id="S4.F5.5.m2.1.1" xref="S4.F5.5.m2.1.1.cmml"><mi id="S4.F5.5.m2.1.1.2" xref="S4.F5.5.m2.1.1.2.cmml">L</mi><mo id="S4.F5.5.m2.1.1.1" xref="S4.F5.5.m2.1.1.1.cmml">=</mo><mn id="S4.F5.5.m2.1.1.3" xref="S4.F5.5.m2.1.1.3.cmml">25</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.F5.5.m2.1c"><apply id="S4.F5.5.m2.1.1.cmml" xref="S4.F5.5.m2.1.1"><eq id="S4.F5.5.m2.1.1.1.cmml" xref="S4.F5.5.m2.1.1.1"></eq><ci id="S4.F5.5.m2.1.1.2.cmml" xref="S4.F5.5.m2.1.1.2">𝐿</ci><cn id="S4.F5.5.m2.1.1.3.cmml" type="integer" xref="S4.F5.5.m2.1.1.3">25</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.F5.5.m2.1d">L=25</annotation><annotation encoding="application/x-llamapun" id="S4.F5.5.m2.1e">italic_L = 25</annotation></semantics></math> in the <math alttext="t" class="ltx_Math" display="inline" id="S4.F5.6.m3.1"><semantics id="S4.F5.6.m3.1b"><mi id="S4.F5.6.m3.1.1" xref="S4.F5.6.m3.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S4.F5.6.m3.1c"><ci id="S4.F5.6.m3.1.1.cmml" xref="S4.F5.6.m3.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.F5.6.m3.1d">t</annotation><annotation encoding="application/x-llamapun" id="S4.F5.6.m3.1e">italic_t</annotation></semantics></math> longest pseudo-MEMs in each read using <span class="ltx_text ltx_font_typewriter" id="S4.F5.15.4">kebab</span> followed by <span class="ltx_text ltx_font_typewriter" id="S4.F5.16.5">tagger</span>.</figcaption>
</figure>
<div class="ltx_para" id="S4.SS2.p3">
<p class="ltx_p" id="S4.SS2.p3.5">We also computed the total times, shown in Figure <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4.F5" title="Figure 5 ‣ 4.2 Metagenomic Classification ‣ 4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">5</span></a>, to classify the reads with <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p3.5.1">tagger</span> after first</p>
<ul class="ltx_itemize" id="S4.I2">
<li class="ltx_item" id="S4.I2.i1" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S4.I2.i1.p1">
<p class="ltx_p" id="S4.I2.i1.p1.1">finding all the MEMs of length at least <math alttext="L" class="ltx_Math" display="inline" id="S4.I2.i1.p1.1.m1.1"><semantics id="S4.I2.i1.p1.1.m1.1a"><mi id="S4.I2.i1.p1.1.m1.1.1" xref="S4.I2.i1.p1.1.m1.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="S4.I2.i1.p1.1.m1.1b"><ci id="S4.I2.i1.p1.1.m1.1.1.cmml" xref="S4.I2.i1.p1.1.m1.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I2.i1.p1.1.m1.1c">L</annotation><annotation encoding="application/x-llamapun" id="S4.I2.i1.p1.1.m1.1d">italic_L</annotation></semantics></math> with <span class="ltx_text ltx_font_typewriter" id="S4.I2.i1.p1.1.1">b-move</span> (“<span class="ltx_text ltx_font_typewriter" id="S4.I2.i1.p1.1.2">tagger</span>”),</p>
</div>
</li>
<li class="ltx_item" id="S4.I2.i2" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S4.I2.i2.p1">
<p class="ltx_p" id="S4.I2.i2.p1.1">finding all the pseudo-MEMs with <span class="ltx_text ltx_font_typewriter" id="S4.I2.i2.p1.1.1">kebab</span> and then finding all the MEMs of length least <math alttext="L" class="ltx_Math" display="inline" id="S4.I2.i2.p1.1.m1.1"><semantics id="S4.I2.i2.p1.1.m1.1a"><mi id="S4.I2.i2.p1.1.m1.1.1" xref="S4.I2.i2.p1.1.m1.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="S4.I2.i2.p1.1.m1.1b"><ci id="S4.I2.i2.p1.1.m1.1.1.cmml" xref="S4.I2.i2.p1.1.m1.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I2.i2.p1.1.m1.1c">L</annotation><annotation encoding="application/x-llamapun" id="S4.I2.i2.p1.1.m1.1d">italic_L</annotation></semantics></math> in them with <span class="ltx_text ltx_font_typewriter" id="S4.I2.i2.p1.1.2">b-move</span> (“<span class="ltx_text ltx_font_typewriter" id="S4.I2.i2.p1.1.3">kebab</span> + <span class="ltx_text ltx_font_typewriter" id="S4.I2.i2.p1.1.4">tagger</span>”),</p>
</div>
</li>
<li class="ltx_item" id="S4.I2.i3" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S4.I2.i3.p1">
<p class="ltx_p" id="S4.I2.i3.p1.3">finding all the pseudo-MEMs with <span class="ltx_text ltx_font_typewriter" id="S4.I2.i3.p1.3.1">kebab</span> and then finding the MEMs of length at least <math alttext="L" class="ltx_Math" display="inline" id="S4.I2.i3.p1.1.m1.1"><semantics id="S4.I2.i3.p1.1.m1.1a"><mi id="S4.I2.i3.p1.1.m1.1.1" xref="S4.I2.i3.p1.1.m1.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="S4.I2.i3.p1.1.m1.1b"><ci id="S4.I2.i3.p1.1.m1.1.1.cmml" xref="S4.I2.i3.p1.1.m1.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I2.i3.p1.1.m1.1c">L</annotation><annotation encoding="application/x-llamapun" id="S4.I2.i3.p1.1.m1.1d">italic_L</annotation></semantics></math> in the <math alttext="t" class="ltx_Math" display="inline" id="S4.I2.i3.p1.2.m2.1"><semantics id="S4.I2.i3.p1.2.m2.1a"><mi id="S4.I2.i3.p1.2.m2.1.1" xref="S4.I2.i3.p1.2.m2.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="S4.I2.i3.p1.2.m2.1b"><ci id="S4.I2.i3.p1.2.m2.1.1.cmml" xref="S4.I2.i3.p1.2.m2.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I2.i3.p1.2.m2.1c">t</annotation><annotation encoding="application/x-llamapun" id="S4.I2.i3.p1.2.m2.1d">italic_t</annotation></semantics></math> longest pseudo-MEMs from each read with <span class="ltx_text ltx_font_typewriter" id="S4.I2.i3.p1.3.2">b-move</span> (“<span class="ltx_text ltx_font_typewriter" id="S4.I2.i3.p1.3.3">kebab</span> + <span class="ltx_text ltx_font_typewriter" id="S4.I2.i3.p1.3.4">tagger</span>, <math alttext="t=30,20,10" class="ltx_Math" display="inline" id="S4.I2.i3.p1.3.m3.3"><semantics id="S4.I2.i3.p1.3.m3.3a"><mrow id="S4.I2.i3.p1.3.m3.3.4" xref="S4.I2.i3.p1.3.m3.3.4.cmml"><mi id="S4.I2.i3.p1.3.m3.3.4.2" xref="S4.I2.i3.p1.3.m3.3.4.2.cmml">t</mi><mo id="S4.I2.i3.p1.3.m3.3.4.1" xref="S4.I2.i3.p1.3.m3.3.4.1.cmml">=</mo><mrow id="S4.I2.i3.p1.3.m3.3.4.3.2" xref="S4.I2.i3.p1.3.m3.3.4.3.1.cmml"><mn id="S4.I2.i3.p1.3.m3.1.1" xref="S4.I2.i3.p1.3.m3.1.1.cmml">30</mn><mo id="S4.I2.i3.p1.3.m3.3.4.3.2.1" xref="S4.I2.i3.p1.3.m3.3.4.3.1.cmml">,</mo><mn id="S4.I2.i3.p1.3.m3.2.2" xref="S4.I2.i3.p1.3.m3.2.2.cmml">20</mn><mo id="S4.I2.i3.p1.3.m3.3.4.3.2.2" xref="S4.I2.i3.p1.3.m3.3.4.3.1.cmml">,</mo><mn id="S4.I2.i3.p1.3.m3.3.3" xref="S4.I2.i3.p1.3.m3.3.3.cmml">10</mn></mrow></mrow><annotation-xml encoding="MathML-Content" id="S4.I2.i3.p1.3.m3.3b"><apply id="S4.I2.i3.p1.3.m3.3.4.cmml" xref="S4.I2.i3.p1.3.m3.3.4"><eq id="S4.I2.i3.p1.3.m3.3.4.1.cmml" xref="S4.I2.i3.p1.3.m3.3.4.1"></eq><ci id="S4.I2.i3.p1.3.m3.3.4.2.cmml" xref="S4.I2.i3.p1.3.m3.3.4.2">𝑡</ci><list id="S4.I2.i3.p1.3.m3.3.4.3.1.cmml" xref="S4.I2.i3.p1.3.m3.3.4.3.2"><cn id="S4.I2.i3.p1.3.m3.1.1.cmml" type="integer" xref="S4.I2.i3.p1.3.m3.1.1">30</cn><cn id="S4.I2.i3.p1.3.m3.2.2.cmml" type="integer" xref="S4.I2.i3.p1.3.m3.2.2">20</cn><cn id="S4.I2.i3.p1.3.m3.3.3.cmml" type="integer" xref="S4.I2.i3.p1.3.m3.3.3">10</cn></list></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.I2.i3.p1.3.m3.3c">t=30,20,10</annotation><annotation encoding="application/x-llamapun" id="S4.I2.i3.p1.3.m3.3d">italic_t = 30 , 20 , 10</annotation></semantics></math>”).</p>
</div>
</li>
</ul>
<p class="ltx_p" id="S4.SS2.p3.4">We ran <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p3.4.1">tagger</span> with default settings and <math alttext="L=25" class="ltx_Math" display="inline" id="S4.SS2.p3.1.m1.1"><semantics id="S4.SS2.p3.1.m1.1a"><mrow id="S4.SS2.p3.1.m1.1.1" xref="S4.SS2.p3.1.m1.1.1.cmml"><mi id="S4.SS2.p3.1.m1.1.1.2" xref="S4.SS2.p3.1.m1.1.1.2.cmml">L</mi><mo id="S4.SS2.p3.1.m1.1.1.1" xref="S4.SS2.p3.1.m1.1.1.1.cmml">=</mo><mn id="S4.SS2.p3.1.m1.1.1.3" xref="S4.SS2.p3.1.m1.1.1.3.cmml">25</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS2.p3.1.m1.1b"><apply id="S4.SS2.p3.1.m1.1.1.cmml" xref="S4.SS2.p3.1.m1.1.1"><eq id="S4.SS2.p3.1.m1.1.1.1.cmml" xref="S4.SS2.p3.1.m1.1.1.1"></eq><ci id="S4.SS2.p3.1.m1.1.1.2.cmml" xref="S4.SS2.p3.1.m1.1.1.2">𝐿</ci><cn id="S4.SS2.p3.1.m1.1.1.3.cmml" type="integer" xref="S4.SS2.p3.1.m1.1.1.3">25</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p3.1.m1.1c">L=25</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p3.1.m1.1d">italic_L = 25</annotation></semantics></math> and <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p3.4.2">kebab</span> with <math alttext="k=20" class="ltx_Math" display="inline" id="S4.SS2.p3.2.m2.1"><semantics id="S4.SS2.p3.2.m2.1a"><mrow id="S4.SS2.p3.2.m2.1.1" xref="S4.SS2.p3.2.m2.1.1.cmml"><mi id="S4.SS2.p3.2.m2.1.1.2" xref="S4.SS2.p3.2.m2.1.1.2.cmml">k</mi><mo id="S4.SS2.p3.2.m2.1.1.1" xref="S4.SS2.p3.2.m2.1.1.1.cmml">=</mo><mn id="S4.SS2.p3.2.m2.1.1.3" xref="S4.SS2.p3.2.m2.1.1.3.cmml">20</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS2.p3.2.m2.1b"><apply id="S4.SS2.p3.2.m2.1.1.cmml" xref="S4.SS2.p3.2.m2.1.1"><eq id="S4.SS2.p3.2.m2.1.1.1.cmml" xref="S4.SS2.p3.2.m2.1.1.1"></eq><ci id="S4.SS2.p3.2.m2.1.1.2.cmml" xref="S4.SS2.p3.2.m2.1.1.2">𝑘</ci><cn id="S4.SS2.p3.2.m2.1.1.3.cmml" type="integer" xref="S4.SS2.p3.2.m2.1.1.3">20</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p3.2.m2.1c">k=20</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p3.2.m2.1d">italic_k = 20</annotation></semantics></math> and one hash function. The index for <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p3.4.3">b-move</span> took <math alttext="7.869" class="ltx_Math" display="inline" id="S4.SS2.p3.3.m3.1"><semantics id="S4.SS2.p3.3.m3.1a"><mn id="S4.SS2.p3.3.m3.1.1" xref="S4.SS2.p3.3.m3.1.1.cmml">7.869</mn><annotation-xml encoding="MathML-Content" id="S4.SS2.p3.3.m3.1b"><cn id="S4.SS2.p3.3.m3.1.1.cmml" type="float" xref="S4.SS2.p3.3.m3.1.1">7.869</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p3.3.m3.1c">7.869</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p3.3.m3.1d">7.869</annotation></semantics></math> GB and the filter for <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p3.4.4">kebab</span> took an additional <math alttext="0.2684" class="ltx_Math" display="inline" id="S4.SS2.p3.4.m4.1"><semantics id="S4.SS2.p3.4.m4.1a"><mn id="S4.SS2.p3.4.m4.1.1" xref="S4.SS2.p3.4.m4.1.1.cmml">0.2684</mn><annotation-xml encoding="MathML-Content" id="S4.SS2.p3.4.m4.1b"><cn id="S4.SS2.p3.4.m4.1.1.cmml" type="float" xref="S4.SS2.p3.4.m4.1.1">0.2684</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p3.4.m4.1c">0.2684</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p3.4.m4.1d">0.2684</annotation></semantics></math> GB. Clearly, <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p3.4.5">kebab</span> can also speed up <span class="ltx_text ltx_font_typewriter" id="S4.SS2.p3.4.6">tagger</span>’s pipeline.</p>
</div>
<div class="ltx_para" id="S4.SS2.p4">
<span class="ltx_ERROR undefined" id="S4.SS2.p4.1">{credits}</span>
</div>
<section class="ltx_subsubsection" id="S4.SS2.SSS1">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">4.2.1 </span>Acknowledgements</h4>
<div class="ltx_para" id="S4.SS2.SSS1.p1">
<p class="ltx_p" id="S4.SS2.SSS1.p1.1">Many thanks to Finlay Maguire for pointing out the similarities between BML and Boyer-Moore. NKB, MZ, and BL were funded by NIH grants R01HG011392 and R56HG013865 to BL. NKB was also funded by a JHU CS PhD Fellowship and an NSERC PGS-D. LD was funded by a PhD Fellowship FR (1117322N), Research Foundation – Flanders (FWO). TG was funded by NSERC grant RGPIN-07185-2020.</p>
</div>
</section>
<section class="ltx_subsubsection" id="S4.SS2.SSS2">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">4.2.2 </span><span class="ltx_ERROR undefined" id="S4.SS2.SSS2.1.1">\discintname</span>
</h4>
<div class="ltx_para" id="S4.SS2.SSS2.p1">
<p class="ltx_p" id="S4.SS2.SSS2.p1.1">The authors declare no competing interests.</p>
</div>
</section>
</section>
</section>
<section class="ltx_bibliography" id="bib">
<h2 class="ltx_title ltx_title_bibliography">References</h2>
<ul class="ltx_biblist">
<li class="ltx_bibitem" id="bib.bib1">
<span class="ltx_tag ltx_tag_bibitem">[1]</span>
<span class="ltx_bibblock">
Ahmed, O.Y., Rossi, M., Gagie, T., Boucher, C., Langmead, B.: Spumoni 2:
improved classification using a pangenome index of minimizer digests. Genome
Biology <span class="ltx_text ltx_font_bold" id="bib.bib1.1.1">24</span>(1),  122 (2023)

</span>
</li>
<li class="ltx_bibitem" id="bib.bib2">
<span class="ltx_tag ltx_tag_bibitem">[2]</span>
<span class="ltx_bibblock">
Bloom, B.H.: Space/time trade-offs in hash coding with allowable errors.
Communications of the ACM <span class="ltx_text ltx_font_bold" id="bib.bib2.1.1">13</span>(7), 422–426 (1970)

</span>
</li>
<li class="ltx_bibitem" id="bib.bib3">
<span class="ltx_tag ltx_tag_bibitem">[3]</span>
<span class="ltx_bibblock">
Boyer, R.S., Moore, J.S.: A fast string searching algorithm. Communications of
the ACM <span class="ltx_text ltx_font_bold" id="bib.bib3.1.1">20</span>(10), 762–772 (1977)

</span>
</li>
<li class="ltx_bibitem" id="bib.bib4">
<span class="ltx_tag ltx_tag_bibitem">[4]</span>
<span class="ltx_bibblock">
Depuydt, L., Renders, L., Van de Vyver, S., Veys, L., Gagie, T., Fostier, J.:
b-move: Faster lossless approximate pattern matching in a run-length
compressed index. Algorithms for Molecular Biology (accepted)

</span>
</li>
<li class="ltx_bibitem" id="bib.bib5">
<span class="ltx_tag ltx_tag_bibitem">[5]</span>
<span class="ltx_bibblock">
Depuydt, L., Ahmed, O.Y., Fostier, J., Langmead, B., Gagie, T.: Run-length
compressed metagenomic read classification with smem-finding and tagging.
bioRxiv pp. 2025–02 (2025)

</span>
</li>
<li class="ltx_bibitem" id="bib.bib6">
<span class="ltx_tag ltx_tag_bibitem">[6]</span>
<span class="ltx_bibblock">
Ferragina, P., Manzini, G.: Indexing compressed text. Journal of the ACM
<span class="ltx_text ltx_font_bold" id="bib.bib6.1.1">52</span>(4), 552–581 (2005)

</span>
</li>
<li class="ltx_bibitem" id="bib.bib7">
<span class="ltx_tag ltx_tag_bibitem">[7]</span>
<span class="ltx_bibblock">
Flajolet, P., Fusy, É., Gandouet, O., Meunier, F.: Hyperloglog: the
analysis of a near-optimal cardinality estimation algorithm. Discrete
Mathematics &amp; Theoretical Computer Science (2007)

</span>
</li>
<li class="ltx_bibitem" id="bib.bib8">
<span class="ltx_tag ltx_tag_bibitem">[8]</span>
<span class="ltx_bibblock">
Gagie, T.: How to find long maximal exact matches and ignore short ones. In:
Proc. 28th Conference on Developments in Language Theory (DLT). pp. 131–140
(2024)

</span>
</li>
<li class="ltx_bibitem" id="bib.bib9">
<span class="ltx_tag ltx_tag_bibitem">[9]</span>
<span class="ltx_bibblock">
Li, H.: Exploring single-sample SNP and INDEL calling with whole-genome de
novo assembly. Bioinformatics <span class="ltx_text ltx_font_bold" id="bib.bib9.1.1">28</span>(14), 1838–1844 (2012)

</span>
</li>
<li class="ltx_bibitem" id="bib.bib10">
<span class="ltx_tag ltx_tag_bibitem">[10]</span>
<span class="ltx_bibblock">
Li, H.: BWT construction and search at the terabase scale. Bioinformatics
<span class="ltx_text ltx_font_bold" id="bib.bib10.1.1">40</span>(12), btae717 (2024)

</span>
</li>
<li class="ltx_bibitem" id="bib.bib11">
<span class="ltx_tag ltx_tag_bibitem">[11]</span>
<span class="ltx_bibblock">
Mohamadi, H., Chu, J., Vandervalk, B.P., Birol, I.: nthash: recursive
nucleotide hashing. Bioinformatics <span class="ltx_text ltx_font_bold" id="bib.bib11.1.1">32</span>(22), 3492–3494 (2016)

</span>
</li>
<li class="ltx_bibitem" id="bib.bib12">
<span class="ltx_tag ltx_tag_bibitem">[12]</span>
<span class="ltx_bibblock">
Thorup, M.: High speed hashing for integers and strings. arXiv preprint
arXiv:1504.06804 (2015)

</span>
</li>
</ul>
</section>
<section class="ltx_appendix" id="Pt0.A1">
<h2 class="ltx_title ltx_title_appendix">
<span class="ltx_tag ltx_tag_appendix">Appendix 0.A </span>Optimizations</h2>
<section class="ltx_subsection" id="Pt0.A1.SS1">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">0.A.1 </span>Bloom filter</h3>
<div class="ltx_para" id="Pt0.A1.SS1.p1">
<p class="ltx_p" id="Pt0.A1.SS1.p1.13">For a Bloom filter, let <math alttext="n" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p1.1.m1.1"><semantics id="Pt0.A1.SS1.p1.1.m1.1a"><mi id="Pt0.A1.SS1.p1.1.m1.1.1" xref="Pt0.A1.SS1.p1.1.m1.1.1.cmml">n</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p1.1.m1.1b"><ci id="Pt0.A1.SS1.p1.1.m1.1.1.cmml" xref="Pt0.A1.SS1.p1.1.m1.1.1">𝑛</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p1.1.m1.1c">n</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p1.1.m1.1d">italic_n</annotation></semantics></math> be the estimated cardinality of a set to be added, <math alttext="m" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p1.2.m2.1"><semantics id="Pt0.A1.SS1.p1.2.m2.1a"><mi id="Pt0.A1.SS1.p1.2.m2.1.1" xref="Pt0.A1.SS1.p1.2.m2.1.1.cmml">m</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p1.2.m2.1b"><ci id="Pt0.A1.SS1.p1.2.m2.1.1.cmml" xref="Pt0.A1.SS1.p1.2.m2.1.1">𝑚</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p1.2.m2.1c">m</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p1.2.m2.1d">italic_m</annotation></semantics></math> the number of bits used, <math alttext="\epsilon" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p1.3.m3.1"><semantics id="Pt0.A1.SS1.p1.3.m3.1a"><mi id="Pt0.A1.SS1.p1.3.m3.1.1" xref="Pt0.A1.SS1.p1.3.m3.1.1.cmml">ϵ</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p1.3.m3.1b"><ci id="Pt0.A1.SS1.p1.3.m3.1.1.cmml" xref="Pt0.A1.SS1.p1.3.m3.1.1">italic-ϵ</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p1.3.m3.1c">\epsilon</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p1.3.m3.1d">italic_ϵ</annotation></semantics></math> the desired false positive rate, and <math alttext="h" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p1.4.m4.1"><semantics id="Pt0.A1.SS1.p1.4.m4.1a"><mi id="Pt0.A1.SS1.p1.4.m4.1.1" xref="Pt0.A1.SS1.p1.4.m4.1.1.cmml">h</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p1.4.m4.1b"><ci id="Pt0.A1.SS1.p1.4.m4.1.1.cmml" xref="Pt0.A1.SS1.p1.4.m4.1.1">ℎ</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p1.4.m4.1c">h</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p1.4.m4.1d">italic_h</annotation></semantics></math> be the number of hash functions. If the hash functions are universal, the false positive rate can be approximated to <math alttext="\epsilon\approx(1-e^{-hn/m})^{h}" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p1.5.m5.1"><semantics id="Pt0.A1.SS1.p1.5.m5.1a"><mrow id="Pt0.A1.SS1.p1.5.m5.1.1" xref="Pt0.A1.SS1.p1.5.m5.1.1.cmml"><mi id="Pt0.A1.SS1.p1.5.m5.1.1.3" xref="Pt0.A1.SS1.p1.5.m5.1.1.3.cmml">ϵ</mi><mo id="Pt0.A1.SS1.p1.5.m5.1.1.2" xref="Pt0.A1.SS1.p1.5.m5.1.1.2.cmml">≈</mo><msup id="Pt0.A1.SS1.p1.5.m5.1.1.1" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.cmml"><mrow id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.cmml"><mo id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.2" stretchy="false" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.cmml">(</mo><mrow id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.cmml"><mn id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.2" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.2.cmml">1</mn><mo id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.1" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.1.cmml">−</mo><msup id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.cmml"><mi id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.2" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.2.cmml">e</mi><mrow id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.cmml"><mo id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3a" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.cmml">−</mo><mrow id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.cmml"><mrow id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2.cmml"><mi id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2.2" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2.2.cmml">h</mi><mo id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2.1" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2.1.cmml">⁢</mo><mi id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2.3" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2.3.cmml">n</mi></mrow><mo id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.1" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.1.cmml">/</mo><mi id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.3" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.3.cmml">m</mi></mrow></mrow></msup></mrow><mo id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.3" stretchy="false" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.cmml">)</mo></mrow><mi id="Pt0.A1.SS1.p1.5.m5.1.1.1.3" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.3.cmml">h</mi></msup></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p1.5.m5.1b"><apply id="Pt0.A1.SS1.p1.5.m5.1.1.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1"><approx id="Pt0.A1.SS1.p1.5.m5.1.1.2.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.2"></approx><ci id="Pt0.A1.SS1.p1.5.m5.1.1.3.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.3">italic-ϵ</ci><apply id="Pt0.A1.SS1.p1.5.m5.1.1.1.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1"><csymbol cd="ambiguous" id="Pt0.A1.SS1.p1.5.m5.1.1.1.2.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1">superscript</csymbol><apply id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1"><minus id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.1.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.1"></minus><cn id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.2.cmml" type="integer" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.2">1</cn><apply id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3"><csymbol cd="ambiguous" id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.1.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3">superscript</csymbol><ci id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.2.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.2">𝑒</ci><apply id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3"><minus id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.1.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3"></minus><apply id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2"><divide id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.1.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.1"></divide><apply id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2"><times id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2.1.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2.1"></times><ci id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2.2.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2.2">ℎ</ci><ci id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2.3.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.2.3">𝑛</ci></apply><ci id="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.3.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.1.1.1.3.3.2.3">𝑚</ci></apply></apply></apply></apply><ci id="Pt0.A1.SS1.p1.5.m5.1.1.1.3.cmml" xref="Pt0.A1.SS1.p1.5.m5.1.1.1.3">ℎ</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p1.5.m5.1c">\epsilon\approx(1-e^{-hn/m})^{h}</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p1.5.m5.1d">italic_ϵ ≈ ( 1 - italic_e start_POSTSUPERSCRIPT - italic_h italic_n / italic_m end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_h end_POSTSUPERSCRIPT</annotation></semantics></math>. Assuming this approximation and given <math alttext="n" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p1.6.m6.1"><semantics id="Pt0.A1.SS1.p1.6.m6.1a"><mi id="Pt0.A1.SS1.p1.6.m6.1.1" xref="Pt0.A1.SS1.p1.6.m6.1.1.cmml">n</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p1.6.m6.1b"><ci id="Pt0.A1.SS1.p1.6.m6.1.1.cmml" xref="Pt0.A1.SS1.p1.6.m6.1.1">𝑛</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p1.6.m6.1c">n</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p1.6.m6.1d">italic_n</annotation></semantics></math>, <math alttext="\epsilon" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p1.7.m7.1"><semantics id="Pt0.A1.SS1.p1.7.m7.1a"><mi id="Pt0.A1.SS1.p1.7.m7.1.1" xref="Pt0.A1.SS1.p1.7.m7.1.1.cmml">ϵ</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p1.7.m7.1b"><ci id="Pt0.A1.SS1.p1.7.m7.1.1.cmml" xref="Pt0.A1.SS1.p1.7.m7.1.1">italic-ϵ</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p1.7.m7.1c">\epsilon</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p1.7.m7.1d">italic_ϵ</annotation></semantics></math> the minimized filter size is derived as <math alttext="m=\frac{-n\cdot\ln{\epsilon}}{\ln{(2)}^{2}}" class="ltx_math_unparsed" display="inline" id="Pt0.A1.SS1.p1.8.m8.2"><semantics id="Pt0.A1.SS1.p1.8.m8.2a"><mrow id="Pt0.A1.SS1.p1.8.m8.2.3"><mi id="Pt0.A1.SS1.p1.8.m8.2.3.2">m</mi><mo id="Pt0.A1.SS1.p1.8.m8.2.3.1">=</mo><mfrac id="Pt0.A1.SS1.p1.8.m8.2.2"><mrow id="Pt0.A1.SS1.p1.8.m8.2.2.4"><mo id="Pt0.A1.SS1.p1.8.m8.2.2.4a">−</mo><mrow id="Pt0.A1.SS1.p1.8.m8.2.2.4.2"><mi id="Pt0.A1.SS1.p1.8.m8.2.2.4.2.2">n</mi><mo id="Pt0.A1.SS1.p1.8.m8.2.2.4.2.1" lspace="0.222em" rspace="0.222em">⋅</mo><mrow id="Pt0.A1.SS1.p1.8.m8.2.2.4.2.3"><mi id="Pt0.A1.SS1.p1.8.m8.2.2.4.2.3.1">ln</mi><mo id="Pt0.A1.SS1.p1.8.m8.2.2.4.2.3a" lspace="0.167em">⁡</mo><mi id="Pt0.A1.SS1.p1.8.m8.2.2.4.2.3.2">ϵ</mi></mrow></mrow></mrow><mrow id="Pt0.A1.SS1.p1.8.m8.2.2.2"><mi id="Pt0.A1.SS1.p1.8.m8.1.1.1.1">ln</mi><msup id="Pt0.A1.SS1.p1.8.m8.2.2.2.3"><mrow id="Pt0.A1.SS1.p1.8.m8.2.2.2.3.2"><mo id="Pt0.A1.SS1.p1.8.m8.2.2.2.3.2.1" stretchy="false">(</mo><mn id="Pt0.A1.SS1.p1.8.m8.2.2.2.2">2</mn><mo id="Pt0.A1.SS1.p1.8.m8.2.2.2.3.2.2" stretchy="false">)</mo></mrow><mn id="Pt0.A1.SS1.p1.8.m8.2.2.2.3.3">2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p1.8.m8.2b">m=\frac{-n\cdot\ln{\epsilon}}{\ln{(2)}^{2}}</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p1.8.m8.2c">italic_m = divide start_ARG - italic_n ⋅ roman_ln italic_ϵ end_ARG start_ARG roman_ln ( 2 ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG</annotation></semantics></math> with corresponding number of hashes <math alttext="h=\frac{-\ln{\epsilon}}{\ln{2}}" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p1.9.m9.1"><semantics id="Pt0.A1.SS1.p1.9.m9.1a"><mrow id="Pt0.A1.SS1.p1.9.m9.1.1" xref="Pt0.A1.SS1.p1.9.m9.1.1.cmml"><mi id="Pt0.A1.SS1.p1.9.m9.1.1.2" xref="Pt0.A1.SS1.p1.9.m9.1.1.2.cmml">h</mi><mo id="Pt0.A1.SS1.p1.9.m9.1.1.1" xref="Pt0.A1.SS1.p1.9.m9.1.1.1.cmml">=</mo><mfrac id="Pt0.A1.SS1.p1.9.m9.1.1.3" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.cmml"><mrow id="Pt0.A1.SS1.p1.9.m9.1.1.3.2" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.2.cmml"><mo id="Pt0.A1.SS1.p1.9.m9.1.1.3.2a" rspace="0.167em" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.2.cmml">−</mo><mrow id="Pt0.A1.SS1.p1.9.m9.1.1.3.2.2" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.2.2.cmml"><mi id="Pt0.A1.SS1.p1.9.m9.1.1.3.2.2.1" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.2.2.1.cmml">ln</mi><mo id="Pt0.A1.SS1.p1.9.m9.1.1.3.2.2a" lspace="0.167em" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.2.2.cmml">⁡</mo><mi id="Pt0.A1.SS1.p1.9.m9.1.1.3.2.2.2" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.2.2.2.cmml">ϵ</mi></mrow></mrow><mrow id="Pt0.A1.SS1.p1.9.m9.1.1.3.3" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.3.cmml"><mi id="Pt0.A1.SS1.p1.9.m9.1.1.3.3.1" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.3.1.cmml">ln</mi><mo id="Pt0.A1.SS1.p1.9.m9.1.1.3.3a" lspace="0.167em" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.3.cmml">⁡</mo><mn id="Pt0.A1.SS1.p1.9.m9.1.1.3.3.2" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.3.2.cmml">2</mn></mrow></mfrac></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p1.9.m9.1b"><apply id="Pt0.A1.SS1.p1.9.m9.1.1.cmml" xref="Pt0.A1.SS1.p1.9.m9.1.1"><eq id="Pt0.A1.SS1.p1.9.m9.1.1.1.cmml" xref="Pt0.A1.SS1.p1.9.m9.1.1.1"></eq><ci id="Pt0.A1.SS1.p1.9.m9.1.1.2.cmml" xref="Pt0.A1.SS1.p1.9.m9.1.1.2">ℎ</ci><apply id="Pt0.A1.SS1.p1.9.m9.1.1.3.cmml" xref="Pt0.A1.SS1.p1.9.m9.1.1.3"><divide id="Pt0.A1.SS1.p1.9.m9.1.1.3.1.cmml" xref="Pt0.A1.SS1.p1.9.m9.1.1.3"></divide><apply id="Pt0.A1.SS1.p1.9.m9.1.1.3.2.cmml" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.2"><minus id="Pt0.A1.SS1.p1.9.m9.1.1.3.2.1.cmml" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.2"></minus><apply id="Pt0.A1.SS1.p1.9.m9.1.1.3.2.2.cmml" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.2.2"><ln id="Pt0.A1.SS1.p1.9.m9.1.1.3.2.2.1.cmml" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.2.2.1"></ln><ci id="Pt0.A1.SS1.p1.9.m9.1.1.3.2.2.2.cmml" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.2.2.2">italic-ϵ</ci></apply></apply><apply id="Pt0.A1.SS1.p1.9.m9.1.1.3.3.cmml" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.3"><ln id="Pt0.A1.SS1.p1.9.m9.1.1.3.3.1.cmml" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.3.1"></ln><cn id="Pt0.A1.SS1.p1.9.m9.1.1.3.3.2.cmml" type="integer" xref="Pt0.A1.SS1.p1.9.m9.1.1.3.3.2">2</cn></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p1.9.m9.1c">h=\frac{-\ln{\epsilon}}{\ln{2}}</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p1.9.m9.1d">italic_h = divide start_ARG - roman_ln italic_ϵ end_ARG start_ARG roman_ln 2 end_ARG</annotation></semantics></math>. However, we can use fewer hashes for extra speed at the expense of a larger filter size; this is desirable for <span class="ltx_text ltx_font_typewriter" id="Pt0.A1.SS1.p1.13.1">kebab</span> which is already small in comparison with MEM-finding indexes. Given <math alttext="h" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p1.10.m10.1"><semantics id="Pt0.A1.SS1.p1.10.m10.1a"><mi id="Pt0.A1.SS1.p1.10.m10.1.1" xref="Pt0.A1.SS1.p1.10.m10.1.1.cmml">h</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p1.10.m10.1b"><ci id="Pt0.A1.SS1.p1.10.m10.1.1.cmml" xref="Pt0.A1.SS1.p1.10.m10.1.1">ℎ</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p1.10.m10.1c">h</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p1.10.m10.1d">italic_h</annotation></semantics></math> in addition to <math alttext="n" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p1.11.m11.1"><semantics id="Pt0.A1.SS1.p1.11.m11.1a"><mi id="Pt0.A1.SS1.p1.11.m11.1.1" xref="Pt0.A1.SS1.p1.11.m11.1.1.cmml">n</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p1.11.m11.1b"><ci id="Pt0.A1.SS1.p1.11.m11.1.1.cmml" xref="Pt0.A1.SS1.p1.11.m11.1.1">𝑛</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p1.11.m11.1c">n</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p1.11.m11.1d">italic_n</annotation></semantics></math>,<math alttext="\epsilon" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p1.12.m12.1"><semantics id="Pt0.A1.SS1.p1.12.m12.1a"><mi id="Pt0.A1.SS1.p1.12.m12.1.1" xref="Pt0.A1.SS1.p1.12.m12.1.1.cmml">ϵ</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p1.12.m12.1b"><ci id="Pt0.A1.SS1.p1.12.m12.1.1.cmml" xref="Pt0.A1.SS1.p1.12.m12.1.1">italic-ϵ</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p1.12.m12.1c">\epsilon</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p1.12.m12.1d">italic_ϵ</annotation></semantics></math> we derive the minimized filter size as <math alttext="m=\frac{-h\cdot\ln{n}}{\ln{(1-\epsilon)}^{1/h}}" class="ltx_math_unparsed" display="inline" id="Pt0.A1.SS1.p1.13.m13.1"><semantics id="Pt0.A1.SS1.p1.13.m13.1a"><mrow id="Pt0.A1.SS1.p1.13.m13.1.2"><mi id="Pt0.A1.SS1.p1.13.m13.1.2.2">m</mi><mo id="Pt0.A1.SS1.p1.13.m13.1.2.1">=</mo><mfrac id="Pt0.A1.SS1.p1.13.m13.1.1"><mrow id="Pt0.A1.SS1.p1.13.m13.1.1.3"><mo id="Pt0.A1.SS1.p1.13.m13.1.1.3a">−</mo><mrow id="Pt0.A1.SS1.p1.13.m13.1.1.3.2"><mi id="Pt0.A1.SS1.p1.13.m13.1.1.3.2.2">h</mi><mo id="Pt0.A1.SS1.p1.13.m13.1.1.3.2.1" lspace="0.222em" rspace="0.222em">⋅</mo><mrow id="Pt0.A1.SS1.p1.13.m13.1.1.3.2.3"><mi id="Pt0.A1.SS1.p1.13.m13.1.1.3.2.3.1">ln</mi><mo id="Pt0.A1.SS1.p1.13.m13.1.1.3.2.3a" lspace="0.167em">⁡</mo><mi id="Pt0.A1.SS1.p1.13.m13.1.1.3.2.3.2">n</mi></mrow></mrow></mrow><mrow id="Pt0.A1.SS1.p1.13.m13.1.1.1"><mi id="Pt0.A1.SS1.p1.13.m13.1.1.1.1">ln</mi><msup id="Pt0.A1.SS1.p1.13.m13.1.1.1.2"><mrow id="Pt0.A1.SS1.p1.13.m13.1.1.1.2.2"><mo id="Pt0.A1.SS1.p1.13.m13.1.1.1.2.2.1" stretchy="false">(</mo><mn id="Pt0.A1.SS1.p1.13.m13.1.1.1.2.2.2">1</mn><mo id="Pt0.A1.SS1.p1.13.m13.1.1.1.2.2.3">−</mo><mi id="Pt0.A1.SS1.p1.13.m13.1.1.1.2.2.4">ϵ</mi><mo id="Pt0.A1.SS1.p1.13.m13.1.1.1.2.2.5" stretchy="false">)</mo></mrow><mrow id="Pt0.A1.SS1.p1.13.m13.1.1.1.2.3"><mn id="Pt0.A1.SS1.p1.13.m13.1.1.1.2.3.2">1</mn><mo id="Pt0.A1.SS1.p1.13.m13.1.1.1.2.3.1">/</mo><mi id="Pt0.A1.SS1.p1.13.m13.1.1.1.2.3.3">h</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p1.13.m13.1b">m=\frac{-h\cdot\ln{n}}{\ln{(1-\epsilon)}^{1/h}}</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p1.13.m13.1c">italic_m = divide start_ARG - italic_h ⋅ roman_ln italic_n end_ARG start_ARG roman_ln ( 1 - italic_ϵ ) start_POSTSUPERSCRIPT 1 / italic_h end_POSTSUPERSCRIPT end_ARG</annotation></semantics></math>.</p>
</div>
<div class="ltx_para" id="Pt0.A1.SS1.p2">
<p class="ltx_p" id="Pt0.A1.SS1.p2.6">Inserting into and querying the Bloom filter can still be slowed even using small <math alttext="h" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p2.1.m1.1"><semantics id="Pt0.A1.SS1.p2.1.m1.1a"><mi id="Pt0.A1.SS1.p2.1.m1.1.1" xref="Pt0.A1.SS1.p2.1.m1.1.1.cmml">h</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p2.1.m1.1b"><ci id="Pt0.A1.SS1.p2.1.m1.1.1.cmml" xref="Pt0.A1.SS1.p2.1.m1.1.1">ℎ</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p2.1.m1.1c">h</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p2.1.m1.1d">italic_h</annotation></semantics></math> due to the need to perform integer modulo of a hash value into the domain <math alttext="[0,m)" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p2.2.m2.2"><semantics id="Pt0.A1.SS1.p2.2.m2.2a"><mrow id="Pt0.A1.SS1.p2.2.m2.2.3.2" xref="Pt0.A1.SS1.p2.2.m2.2.3.1.cmml"><mo id="Pt0.A1.SS1.p2.2.m2.2.3.2.1" stretchy="false" xref="Pt0.A1.SS1.p2.2.m2.2.3.1.cmml">[</mo><mn id="Pt0.A1.SS1.p2.2.m2.1.1" xref="Pt0.A1.SS1.p2.2.m2.1.1.cmml">0</mn><mo id="Pt0.A1.SS1.p2.2.m2.2.3.2.2" xref="Pt0.A1.SS1.p2.2.m2.2.3.1.cmml">,</mo><mi id="Pt0.A1.SS1.p2.2.m2.2.2" xref="Pt0.A1.SS1.p2.2.m2.2.2.cmml">m</mi><mo id="Pt0.A1.SS1.p2.2.m2.2.3.2.3" stretchy="false" xref="Pt0.A1.SS1.p2.2.m2.2.3.1.cmml">)</mo></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p2.2.m2.2b"><interval closure="closed-open" id="Pt0.A1.SS1.p2.2.m2.2.3.1.cmml" xref="Pt0.A1.SS1.p2.2.m2.2.3.2"><cn id="Pt0.A1.SS1.p2.2.m2.1.1.cmml" type="integer" xref="Pt0.A1.SS1.p2.2.m2.1.1">0</cn><ci id="Pt0.A1.SS1.p2.2.m2.2.2.cmml" xref="Pt0.A1.SS1.p2.2.m2.2.2">𝑚</ci></interval></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p2.2.m2.2c">[0,m)</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p2.2.m2.2d">[ 0 , italic_m )</annotation></semantics></math>. <span class="ltx_text ltx_font_italic" id="Pt0.A1.SS1.p2.6.1">Fibonacci hashing</span> avoids an explicit modulo by ensuring that the domain size is a power of 2. Working with <math alttext="64" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p2.3.m3.1"><semantics id="Pt0.A1.SS1.p2.3.m3.1a"><mn id="Pt0.A1.SS1.p2.3.m3.1.1" xref="Pt0.A1.SS1.p2.3.m3.1.1.cmml">64</mn><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p2.3.m3.1b"><cn id="Pt0.A1.SS1.p2.3.m3.1.1.cmml" type="integer" xref="Pt0.A1.SS1.p2.3.m3.1.1">64</cn></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p2.3.m3.1c">64</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p2.3.m3.1d">64</annotation></semantics></math> bits, a hash is computed by multiplying the current value by the golden ratio and then right shifting away <math alttext="64-\log_{2}{m}" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p2.4.m4.1"><semantics id="Pt0.A1.SS1.p2.4.m4.1a"><mrow id="Pt0.A1.SS1.p2.4.m4.1.1" xref="Pt0.A1.SS1.p2.4.m4.1.1.cmml"><mn id="Pt0.A1.SS1.p2.4.m4.1.1.2" xref="Pt0.A1.SS1.p2.4.m4.1.1.2.cmml">64</mn><mo id="Pt0.A1.SS1.p2.4.m4.1.1.1" xref="Pt0.A1.SS1.p2.4.m4.1.1.1.cmml">−</mo><mrow id="Pt0.A1.SS1.p2.4.m4.1.1.3" xref="Pt0.A1.SS1.p2.4.m4.1.1.3.cmml"><msub id="Pt0.A1.SS1.p2.4.m4.1.1.3.1" xref="Pt0.A1.SS1.p2.4.m4.1.1.3.1.cmml"><mi id="Pt0.A1.SS1.p2.4.m4.1.1.3.1.2" xref="Pt0.A1.SS1.p2.4.m4.1.1.3.1.2.cmml">log</mi><mn id="Pt0.A1.SS1.p2.4.m4.1.1.3.1.3" xref="Pt0.A1.SS1.p2.4.m4.1.1.3.1.3.cmml">2</mn></msub><mo id="Pt0.A1.SS1.p2.4.m4.1.1.3a" lspace="0.167em" xref="Pt0.A1.SS1.p2.4.m4.1.1.3.cmml">⁡</mo><mi id="Pt0.A1.SS1.p2.4.m4.1.1.3.2" xref="Pt0.A1.SS1.p2.4.m4.1.1.3.2.cmml">m</mi></mrow></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p2.4.m4.1b"><apply id="Pt0.A1.SS1.p2.4.m4.1.1.cmml" xref="Pt0.A1.SS1.p2.4.m4.1.1"><minus id="Pt0.A1.SS1.p2.4.m4.1.1.1.cmml" xref="Pt0.A1.SS1.p2.4.m4.1.1.1"></minus><cn id="Pt0.A1.SS1.p2.4.m4.1.1.2.cmml" type="integer" xref="Pt0.A1.SS1.p2.4.m4.1.1.2">64</cn><apply id="Pt0.A1.SS1.p2.4.m4.1.1.3.cmml" xref="Pt0.A1.SS1.p2.4.m4.1.1.3"><apply id="Pt0.A1.SS1.p2.4.m4.1.1.3.1.cmml" xref="Pt0.A1.SS1.p2.4.m4.1.1.3.1"><csymbol cd="ambiguous" id="Pt0.A1.SS1.p2.4.m4.1.1.3.1.1.cmml" xref="Pt0.A1.SS1.p2.4.m4.1.1.3.1">subscript</csymbol><log id="Pt0.A1.SS1.p2.4.m4.1.1.3.1.2.cmml" xref="Pt0.A1.SS1.p2.4.m4.1.1.3.1.2"></log><cn id="Pt0.A1.SS1.p2.4.m4.1.1.3.1.3.cmml" type="integer" xref="Pt0.A1.SS1.p2.4.m4.1.1.3.1.3">2</cn></apply><ci id="Pt0.A1.SS1.p2.4.m4.1.1.3.2.cmml" xref="Pt0.A1.SS1.p2.4.m4.1.1.3.2">𝑚</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p2.4.m4.1c">64-\log_{2}{m}</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p2.4.m4.1d">64 - roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_m</annotation></semantics></math> bits. Our implementation instead multiples by fixed seeds, but this is still universal <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib12" title="">12</a>]</cite>. After computing our filter size <math alttext="m" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p2.5.m5.1"><semantics id="Pt0.A1.SS1.p2.5.m5.1a"><mi id="Pt0.A1.SS1.p2.5.m5.1.1" xref="Pt0.A1.SS1.p2.5.m5.1.1.cmml">m</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p2.5.m5.1b"><ci id="Pt0.A1.SS1.p2.5.m5.1.1.cmml" xref="Pt0.A1.SS1.p2.5.m5.1.1">𝑚</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p2.5.m5.1c">m</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p2.5.m5.1d">italic_m</annotation></semantics></math>, we round it down to its previous power of 2, unless it is within <math alttext="10\%" class="ltx_Math" display="inline" id="Pt0.A1.SS1.p2.6.m6.1"><semantics id="Pt0.A1.SS1.p2.6.m6.1a"><mrow id="Pt0.A1.SS1.p2.6.m6.1.1" xref="Pt0.A1.SS1.p2.6.m6.1.1.cmml"><mn id="Pt0.A1.SS1.p2.6.m6.1.1.2" xref="Pt0.A1.SS1.p2.6.m6.1.1.2.cmml">10</mn><mo id="Pt0.A1.SS1.p2.6.m6.1.1.1" xref="Pt0.A1.SS1.p2.6.m6.1.1.1.cmml">%</mo></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS1.p2.6.m6.1b"><apply id="Pt0.A1.SS1.p2.6.m6.1.1.cmml" xref="Pt0.A1.SS1.p2.6.m6.1.1"><csymbol cd="latexml" id="Pt0.A1.SS1.p2.6.m6.1.1.1.cmml" xref="Pt0.A1.SS1.p2.6.m6.1.1.1">percent</csymbol><cn id="Pt0.A1.SS1.p2.6.m6.1.1.2.cmml" type="integer" xref="Pt0.A1.SS1.p2.6.m6.1.1.2">10</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS1.p2.6.m6.1c">10\%</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS1.p2.6.m6.1d">10 %</annotation></semantics></math> of the next power of 2 in which case we round up. This can cause the false positive rate to grow but results in fast and small filters with acceptable error in our experiments.</p>
</div>
</section>
<section class="ltx_subsection" id="Pt0.A1.SS2">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">0.A.2 </span><math alttext="k" class="ltx_Math" display="inline" id="Pt0.A1.SS2.1.m1.1"><semantics id="Pt0.A1.SS2.1.m1.1b"><mi id="Pt0.A1.SS2.1.m1.1.1" xref="Pt0.A1.SS2.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.1.m1.1c"><ci id="Pt0.A1.SS2.1.m1.1.1.cmml" xref="Pt0.A1.SS2.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.1.m1.1d">k</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.1.m1.1e">italic_k</annotation></semantics></math>-mer hashing</h3>
<div class="ltx_para" id="Pt0.A1.SS2.p1">
<p class="ltx_p" id="Pt0.A1.SS2.p1.5">To efficiently stream <math alttext="k" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p1.1.m1.1"><semantics id="Pt0.A1.SS2.p1.1.m1.1a"><mi id="Pt0.A1.SS2.p1.1.m1.1.1" xref="Pt0.A1.SS2.p1.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p1.1.m1.1b"><ci id="Pt0.A1.SS2.p1.1.m1.1.1.cmml" xref="Pt0.A1.SS2.p1.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p1.1.m1.1c">k</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p1.1.m1.1d">italic_k</annotation></semantics></math>-mers, we implemented the rolling nucleotide hash defined by Mohamadi et al.’s <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#bib.bib11" title="">11</a>]</cite> ntHash. Let <math alttext="rol" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p1.2.m2.1"><semantics id="Pt0.A1.SS2.p1.2.m2.1a"><mrow id="Pt0.A1.SS2.p1.2.m2.1.1" xref="Pt0.A1.SS2.p1.2.m2.1.1.cmml"><mi id="Pt0.A1.SS2.p1.2.m2.1.1.2" xref="Pt0.A1.SS2.p1.2.m2.1.1.2.cmml">r</mi><mo id="Pt0.A1.SS2.p1.2.m2.1.1.1" xref="Pt0.A1.SS2.p1.2.m2.1.1.1.cmml">⁢</mo><mi id="Pt0.A1.SS2.p1.2.m2.1.1.3" xref="Pt0.A1.SS2.p1.2.m2.1.1.3.cmml">o</mi><mo id="Pt0.A1.SS2.p1.2.m2.1.1.1a" xref="Pt0.A1.SS2.p1.2.m2.1.1.1.cmml">⁢</mo><mi id="Pt0.A1.SS2.p1.2.m2.1.1.4" xref="Pt0.A1.SS2.p1.2.m2.1.1.4.cmml">l</mi></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p1.2.m2.1b"><apply id="Pt0.A1.SS2.p1.2.m2.1.1.cmml" xref="Pt0.A1.SS2.p1.2.m2.1.1"><times id="Pt0.A1.SS2.p1.2.m2.1.1.1.cmml" xref="Pt0.A1.SS2.p1.2.m2.1.1.1"></times><ci id="Pt0.A1.SS2.p1.2.m2.1.1.2.cmml" xref="Pt0.A1.SS2.p1.2.m2.1.1.2">𝑟</ci><ci id="Pt0.A1.SS2.p1.2.m2.1.1.3.cmml" xref="Pt0.A1.SS2.p1.2.m2.1.1.3">𝑜</ci><ci id="Pt0.A1.SS2.p1.2.m2.1.1.4.cmml" xref="Pt0.A1.SS2.p1.2.m2.1.1.4">𝑙</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p1.2.m2.1c">rol</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p1.2.m2.1d">italic_r italic_o italic_l</annotation></semantics></math> be binary cyclic left rotation, <math alttext="\oplus" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p1.3.m3.1"><semantics id="Pt0.A1.SS2.p1.3.m3.1a"><mo id="Pt0.A1.SS2.p1.3.m3.1.1" xref="Pt0.A1.SS2.p1.3.m3.1.1.cmml">⊕</mo><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p1.3.m3.1b"><csymbol cd="latexml" id="Pt0.A1.SS2.p1.3.m3.1.1.cmml" xref="Pt0.A1.SS2.p1.3.m3.1.1">direct-sum</csymbol></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p1.3.m3.1c">\oplus</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p1.3.m3.1d">⊕</annotation></semantics></math> binary XOR, and assume single bases, e.g. <math alttext="P[i]" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p1.4.m4.1"><semantics id="Pt0.A1.SS2.p1.4.m4.1a"><mrow id="Pt0.A1.SS2.p1.4.m4.1.2" xref="Pt0.A1.SS2.p1.4.m4.1.2.cmml"><mi id="Pt0.A1.SS2.p1.4.m4.1.2.2" xref="Pt0.A1.SS2.p1.4.m4.1.2.2.cmml">P</mi><mo id="Pt0.A1.SS2.p1.4.m4.1.2.1" xref="Pt0.A1.SS2.p1.4.m4.1.2.1.cmml">⁢</mo><mrow id="Pt0.A1.SS2.p1.4.m4.1.2.3.2" xref="Pt0.A1.SS2.p1.4.m4.1.2.3.1.cmml"><mo id="Pt0.A1.SS2.p1.4.m4.1.2.3.2.1" stretchy="false" xref="Pt0.A1.SS2.p1.4.m4.1.2.3.1.1.cmml">[</mo><mi id="Pt0.A1.SS2.p1.4.m4.1.1" xref="Pt0.A1.SS2.p1.4.m4.1.1.cmml">i</mi><mo id="Pt0.A1.SS2.p1.4.m4.1.2.3.2.2" stretchy="false" xref="Pt0.A1.SS2.p1.4.m4.1.2.3.1.1.cmml">]</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p1.4.m4.1b"><apply id="Pt0.A1.SS2.p1.4.m4.1.2.cmml" xref="Pt0.A1.SS2.p1.4.m4.1.2"><times id="Pt0.A1.SS2.p1.4.m4.1.2.1.cmml" xref="Pt0.A1.SS2.p1.4.m4.1.2.1"></times><ci id="Pt0.A1.SS2.p1.4.m4.1.2.2.cmml" xref="Pt0.A1.SS2.p1.4.m4.1.2.2">𝑃</ci><apply id="Pt0.A1.SS2.p1.4.m4.1.2.3.1.cmml" xref="Pt0.A1.SS2.p1.4.m4.1.2.3.2"><csymbol cd="latexml" id="Pt0.A1.SS2.p1.4.m4.1.2.3.1.1.cmml" xref="Pt0.A1.SS2.p1.4.m4.1.2.3.2.1">delimited-[]</csymbol><ci id="Pt0.A1.SS2.p1.4.m4.1.1.cmml" xref="Pt0.A1.SS2.p1.4.m4.1.1">𝑖</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p1.4.m4.1c">P[i]</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p1.4.m4.1d">italic_P [ italic_i ]</annotation></semantics></math>, are replaced with a seed corresponding to the base at <math alttext="P[i]" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p1.5.m5.1"><semantics id="Pt0.A1.SS2.p1.5.m5.1a"><mrow id="Pt0.A1.SS2.p1.5.m5.1.2" xref="Pt0.A1.SS2.p1.5.m5.1.2.cmml"><mi id="Pt0.A1.SS2.p1.5.m5.1.2.2" xref="Pt0.A1.SS2.p1.5.m5.1.2.2.cmml">P</mi><mo id="Pt0.A1.SS2.p1.5.m5.1.2.1" xref="Pt0.A1.SS2.p1.5.m5.1.2.1.cmml">⁢</mo><mrow id="Pt0.A1.SS2.p1.5.m5.1.2.3.2" xref="Pt0.A1.SS2.p1.5.m5.1.2.3.1.cmml"><mo id="Pt0.A1.SS2.p1.5.m5.1.2.3.2.1" stretchy="false" xref="Pt0.A1.SS2.p1.5.m5.1.2.3.1.1.cmml">[</mo><mi id="Pt0.A1.SS2.p1.5.m5.1.1" xref="Pt0.A1.SS2.p1.5.m5.1.1.cmml">i</mi><mo id="Pt0.A1.SS2.p1.5.m5.1.2.3.2.2" stretchy="false" xref="Pt0.A1.SS2.p1.5.m5.1.2.3.1.1.cmml">]</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p1.5.m5.1b"><apply id="Pt0.A1.SS2.p1.5.m5.1.2.cmml" xref="Pt0.A1.SS2.p1.5.m5.1.2"><times id="Pt0.A1.SS2.p1.5.m5.1.2.1.cmml" xref="Pt0.A1.SS2.p1.5.m5.1.2.1"></times><ci id="Pt0.A1.SS2.p1.5.m5.1.2.2.cmml" xref="Pt0.A1.SS2.p1.5.m5.1.2.2">𝑃</ci><apply id="Pt0.A1.SS2.p1.5.m5.1.2.3.1.cmml" xref="Pt0.A1.SS2.p1.5.m5.1.2.3.2"><csymbol cd="latexml" id="Pt0.A1.SS2.p1.5.m5.1.2.3.1.1.cmml" xref="Pt0.A1.SS2.p1.5.m5.1.2.3.2.1">delimited-[]</csymbol><ci id="Pt0.A1.SS2.p1.5.m5.1.1.cmml" xref="Pt0.A1.SS2.p1.5.m5.1.1">𝑖</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p1.5.m5.1c">P[i]</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p1.5.m5.1d">italic_P [ italic_i ]</annotation></semantics></math>. The initial hash value is given by</p>
<table class="ltx_equation ltx_eqn_table" id="Pt0.A1.Ex1">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="H(P[0..k-1])=rol^{k-1}(P[0])\oplus rol^{k-2}(P[1])\oplus...\oplus P[k-1]" class="ltx_math_unparsed" display="block" id="Pt0.A1.Ex1.m1.1"><semantics id="Pt0.A1.Ex1.m1.1a"><mrow id="Pt0.A1.Ex1.m1.1b"><mi id="Pt0.A1.Ex1.m1.1.1" mathsize="90%">H</mi><mrow id="Pt0.A1.Ex1.m1.1.2"><mo id="Pt0.A1.Ex1.m1.1.2.1" maxsize="90%" minsize="90%">(</mo><mi id="Pt0.A1.Ex1.m1.1.2.2" mathsize="90%">P</mi><mrow id="Pt0.A1.Ex1.m1.1.2.3"><mo id="Pt0.A1.Ex1.m1.1.2.3.1" maxsize="90%" minsize="90%">[</mo><mn id="Pt0.A1.Ex1.m1.1.2.3.2" mathsize="90%">0</mn><mo id="Pt0.A1.Ex1.m1.1.2.3.3" lspace="0em" mathsize="90%" rspace="0.0835em">.</mo><mo id="Pt0.A1.Ex1.m1.1.2.3.4" lspace="0.0835em" mathsize="90%" rspace="0.167em">.</mo><mi id="Pt0.A1.Ex1.m1.1.2.3.5" mathsize="90%">k</mi><mo id="Pt0.A1.Ex1.m1.1.2.3.6" mathsize="90%">−</mo><mn id="Pt0.A1.Ex1.m1.1.2.3.7" mathsize="90%">1</mn><mo id="Pt0.A1.Ex1.m1.1.2.3.8" maxsize="90%" minsize="90%">]</mo></mrow><mo id="Pt0.A1.Ex1.m1.1.2.4" maxsize="90%" minsize="90%">)</mo></mrow><mo id="Pt0.A1.Ex1.m1.1.3" mathsize="90%">=</mo><mi id="Pt0.A1.Ex1.m1.1.4" mathsize="90%">r</mi><mi id="Pt0.A1.Ex1.m1.1.5" mathsize="90%">o</mi><msup id="Pt0.A1.Ex1.m1.1.6"><mi id="Pt0.A1.Ex1.m1.1.6.2" mathsize="90%">l</mi><mrow id="Pt0.A1.Ex1.m1.1.6.3"><mi id="Pt0.A1.Ex1.m1.1.6.3.2" mathsize="90%">k</mi><mo id="Pt0.A1.Ex1.m1.1.6.3.1" mathsize="90%">−</mo><mn id="Pt0.A1.Ex1.m1.1.6.3.3" mathsize="90%">1</mn></mrow></msup><mrow id="Pt0.A1.Ex1.m1.1.7"><mo id="Pt0.A1.Ex1.m1.1.7.1" maxsize="90%" minsize="90%">(</mo><mi id="Pt0.A1.Ex1.m1.1.7.2" mathsize="90%">P</mi><mrow id="Pt0.A1.Ex1.m1.1.7.3"><mo id="Pt0.A1.Ex1.m1.1.7.3.1" maxsize="90%" minsize="90%">[</mo><mn id="Pt0.A1.Ex1.m1.1.7.3.2" mathsize="90%">0</mn><mo id="Pt0.A1.Ex1.m1.1.7.3.3" maxsize="90%" minsize="90%">]</mo></mrow><mo id="Pt0.A1.Ex1.m1.1.7.4" maxsize="90%" minsize="90%">)</mo></mrow><mo id="Pt0.A1.Ex1.m1.1.8" mathsize="90%">⊕</mo><mi id="Pt0.A1.Ex1.m1.1.9" mathsize="90%">r</mi><mi id="Pt0.A1.Ex1.m1.1.10" mathsize="90%">o</mi><msup id="Pt0.A1.Ex1.m1.1.11"><mi id="Pt0.A1.Ex1.m1.1.11.2" mathsize="90%">l</mi><mrow id="Pt0.A1.Ex1.m1.1.11.3"><mi id="Pt0.A1.Ex1.m1.1.11.3.2" mathsize="90%">k</mi><mo id="Pt0.A1.Ex1.m1.1.11.3.1" mathsize="90%">−</mo><mn id="Pt0.A1.Ex1.m1.1.11.3.3" mathsize="90%">2</mn></mrow></msup><mrow id="Pt0.A1.Ex1.m1.1.12"><mo id="Pt0.A1.Ex1.m1.1.12.1" maxsize="90%" minsize="90%">(</mo><mi id="Pt0.A1.Ex1.m1.1.12.2" mathsize="90%">P</mi><mrow id="Pt0.A1.Ex1.m1.1.12.3"><mo id="Pt0.A1.Ex1.m1.1.12.3.1" maxsize="90%" minsize="90%">[</mo><mn id="Pt0.A1.Ex1.m1.1.12.3.2" mathsize="90%">1</mn><mo id="Pt0.A1.Ex1.m1.1.12.3.3" maxsize="90%" minsize="90%">]</mo></mrow><mo id="Pt0.A1.Ex1.m1.1.12.4" maxsize="90%" minsize="90%">)</mo></mrow><mo id="Pt0.A1.Ex1.m1.1.13" mathsize="90%">⊕</mo><mi id="Pt0.A1.Ex1.m1.1.14" mathsize="90%" mathvariant="normal">…</mi><mo id="Pt0.A1.Ex1.m1.1.15" mathsize="90%">⊕</mo><mi id="Pt0.A1.Ex1.m1.1.16" mathsize="90%">P</mi><mrow id="Pt0.A1.Ex1.m1.1.17"><mo id="Pt0.A1.Ex1.m1.1.17.1" maxsize="90%" minsize="90%">[</mo><mi id="Pt0.A1.Ex1.m1.1.17.2" mathsize="90%">k</mi><mo id="Pt0.A1.Ex1.m1.1.17.3" mathsize="90%">−</mo><mn id="Pt0.A1.Ex1.m1.1.17.4" mathsize="90%">1</mn><mo id="Pt0.A1.Ex1.m1.1.17.5" maxsize="90%" minsize="90%">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="Pt0.A1.Ex1.m1.1c">H(P[0..k-1])=rol^{k-1}(P[0])\oplus rol^{k-2}(P[1])\oplus...\oplus P[k-1]</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.Ex1.m1.1d">italic_H ( italic_P [ 0 . . italic_k - 1 ] ) = italic_r italic_o italic_l start_POSTSUPERSCRIPT italic_k - 1 end_POSTSUPERSCRIPT ( italic_P [ 0 ] ) ⊕ italic_r italic_o italic_l start_POSTSUPERSCRIPT italic_k - 2 end_POSTSUPERSCRIPT ( italic_P [ 1 ] ) ⊕ … ⊕ italic_P [ italic_k - 1 ]</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p class="ltx_p" id="Pt0.A1.SS2.p1.6">and subsequent <math alttext="k" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p1.6.m1.1"><semantics id="Pt0.A1.SS2.p1.6.m1.1a"><mi id="Pt0.A1.SS2.p1.6.m1.1.1" xref="Pt0.A1.SS2.p1.6.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p1.6.m1.1b"><ci id="Pt0.A1.SS2.p1.6.m1.1.1.cmml" xref="Pt0.A1.SS2.p1.6.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p1.6.m1.1c">k</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p1.6.m1.1d">italic_k</annotation></semantics></math>-mers computed from the previous as</p>
<table class="ltx_equation ltx_eqn_table" id="Pt0.A1.Ex2">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="H(P[i..i+k-1])=rol(H(P[i-1..i+k-2]))\oplus rol^{k}(P[i-1])\oplus P[i+k-1]" class="ltx_math_unparsed" display="block" id="Pt0.A1.Ex2.m1.1"><semantics id="Pt0.A1.Ex2.m1.1a"><mrow id="Pt0.A1.Ex2.m1.1b"><mi id="Pt0.A1.Ex2.m1.1.1" mathsize="90%">H</mi><mrow id="Pt0.A1.Ex2.m1.1.2"><mo id="Pt0.A1.Ex2.m1.1.2.1" maxsize="90%" minsize="90%">(</mo><mi id="Pt0.A1.Ex2.m1.1.2.2" mathsize="90%">P</mi><mrow id="Pt0.A1.Ex2.m1.1.2.3"><mo id="Pt0.A1.Ex2.m1.1.2.3.1" maxsize="90%" minsize="90%">[</mo><mi id="Pt0.A1.Ex2.m1.1.2.3.2" mathsize="90%">i</mi><mo id="Pt0.A1.Ex2.m1.1.2.3.3" lspace="0em" mathsize="90%" rspace="0.0835em">.</mo><mo id="Pt0.A1.Ex2.m1.1.2.3.4" lspace="0.0835em" mathsize="90%" rspace="0.167em">.</mo><mi id="Pt0.A1.Ex2.m1.1.2.3.5" mathsize="90%">i</mi><mo id="Pt0.A1.Ex2.m1.1.2.3.6" mathsize="90%">+</mo><mi id="Pt0.A1.Ex2.m1.1.2.3.7" mathsize="90%">k</mi><mo id="Pt0.A1.Ex2.m1.1.2.3.8" mathsize="90%">−</mo><mn id="Pt0.A1.Ex2.m1.1.2.3.9" mathsize="90%">1</mn><mo id="Pt0.A1.Ex2.m1.1.2.3.10" maxsize="90%" minsize="90%">]</mo></mrow><mo id="Pt0.A1.Ex2.m1.1.2.4" maxsize="90%" minsize="90%">)</mo></mrow><mo id="Pt0.A1.Ex2.m1.1.3" mathsize="90%">=</mo><mi id="Pt0.A1.Ex2.m1.1.4" mathsize="90%">r</mi><mi id="Pt0.A1.Ex2.m1.1.5" mathsize="90%">o</mi><mi id="Pt0.A1.Ex2.m1.1.6" mathsize="90%">l</mi><mrow id="Pt0.A1.Ex2.m1.1.7"><mo id="Pt0.A1.Ex2.m1.1.7.1" maxsize="90%" minsize="90%">(</mo><mi id="Pt0.A1.Ex2.m1.1.7.2" mathsize="90%">H</mi><mrow id="Pt0.A1.Ex2.m1.1.7.3"><mo id="Pt0.A1.Ex2.m1.1.7.3.1" maxsize="90%" minsize="90%">(</mo><mi id="Pt0.A1.Ex2.m1.1.7.3.2" mathsize="90%">P</mi><mrow id="Pt0.A1.Ex2.m1.1.7.3.3"><mo id="Pt0.A1.Ex2.m1.1.7.3.3.1" maxsize="90%" minsize="90%">[</mo><mi id="Pt0.A1.Ex2.m1.1.7.3.3.2" mathsize="90%">i</mi><mo id="Pt0.A1.Ex2.m1.1.7.3.3.3" mathsize="90%">−</mo><mn id="Pt0.A1.Ex2.m1.1.7.3.3.4" mathsize="90%">1</mn><mo id="Pt0.A1.Ex2.m1.1.7.3.3.5" lspace="0em" mathsize="90%" rspace="0.0835em">.</mo><mo id="Pt0.A1.Ex2.m1.1.7.3.3.6" lspace="0.0835em" mathsize="90%" rspace="0.167em">.</mo><mi id="Pt0.A1.Ex2.m1.1.7.3.3.7" mathsize="90%">i</mi><mo id="Pt0.A1.Ex2.m1.1.7.3.3.8" mathsize="90%">+</mo><mi id="Pt0.A1.Ex2.m1.1.7.3.3.9" mathsize="90%">k</mi><mo id="Pt0.A1.Ex2.m1.1.7.3.3.10" mathsize="90%">−</mo><mn id="Pt0.A1.Ex2.m1.1.7.3.3.11" mathsize="90%">2</mn><mo id="Pt0.A1.Ex2.m1.1.7.3.3.12" maxsize="90%" minsize="90%">]</mo></mrow><mo id="Pt0.A1.Ex2.m1.1.7.3.4" maxsize="90%" minsize="90%">)</mo></mrow><mo id="Pt0.A1.Ex2.m1.1.7.4" maxsize="90%" minsize="90%">)</mo></mrow><mo id="Pt0.A1.Ex2.m1.1.8" mathsize="90%">⊕</mo><mi id="Pt0.A1.Ex2.m1.1.9" mathsize="90%">r</mi><mi id="Pt0.A1.Ex2.m1.1.10" mathsize="90%">o</mi><msup id="Pt0.A1.Ex2.m1.1.11"><mi id="Pt0.A1.Ex2.m1.1.11.2" mathsize="90%">l</mi><mi id="Pt0.A1.Ex2.m1.1.11.3" mathsize="90%">k</mi></msup><mrow id="Pt0.A1.Ex2.m1.1.12"><mo id="Pt0.A1.Ex2.m1.1.12.1" maxsize="90%" minsize="90%">(</mo><mi id="Pt0.A1.Ex2.m1.1.12.2" mathsize="90%">P</mi><mrow id="Pt0.A1.Ex2.m1.1.12.3"><mo id="Pt0.A1.Ex2.m1.1.12.3.1" maxsize="90%" minsize="90%">[</mo><mi id="Pt0.A1.Ex2.m1.1.12.3.2" mathsize="90%">i</mi><mo id="Pt0.A1.Ex2.m1.1.12.3.3" mathsize="90%">−</mo><mn id="Pt0.A1.Ex2.m1.1.12.3.4" mathsize="90%">1</mn><mo id="Pt0.A1.Ex2.m1.1.12.3.5" maxsize="90%" minsize="90%">]</mo></mrow><mo id="Pt0.A1.Ex2.m1.1.12.4" maxsize="90%" minsize="90%">)</mo></mrow><mo id="Pt0.A1.Ex2.m1.1.13" mathsize="90%">⊕</mo><mi id="Pt0.A1.Ex2.m1.1.14" mathsize="90%">P</mi><mrow id="Pt0.A1.Ex2.m1.1.15"><mo id="Pt0.A1.Ex2.m1.1.15.1" maxsize="90%" minsize="90%">[</mo><mi id="Pt0.A1.Ex2.m1.1.15.2" mathsize="90%">i</mi><mo id="Pt0.A1.Ex2.m1.1.15.3" mathsize="90%">+</mo><mi id="Pt0.A1.Ex2.m1.1.15.4" mathsize="90%">k</mi><mo id="Pt0.A1.Ex2.m1.1.15.5" mathsize="90%">−</mo><mn id="Pt0.A1.Ex2.m1.1.15.6" mathsize="90%">1</mn><mo id="Pt0.A1.Ex2.m1.1.15.7" maxsize="90%" minsize="90%">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="Pt0.A1.Ex2.m1.1c">H(P[i..i+k-1])=rol(H(P[i-1..i+k-2]))\oplus rol^{k}(P[i-1])\oplus P[i+k-1]</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.Ex2.m1.1d">italic_H ( italic_P [ italic_i . . italic_i + italic_k - 1 ] ) = italic_r italic_o italic_l ( italic_H ( italic_P [ italic_i - 1 . . italic_i + italic_k - 2 ] ) ) ⊕ italic_r italic_o italic_l start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ( italic_P [ italic_i - 1 ] ) ⊕ italic_P [ italic_i + italic_k - 1 ]</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p class="ltx_p" id="Pt0.A1.SS2.p1.11">which can be seen as removing the outgoing base <math alttext="P[i-1]" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p1.7.m1.1"><semantics id="Pt0.A1.SS2.p1.7.m1.1a"><mrow id="Pt0.A1.SS2.p1.7.m1.1.1" xref="Pt0.A1.SS2.p1.7.m1.1.1.cmml"><mi id="Pt0.A1.SS2.p1.7.m1.1.1.3" xref="Pt0.A1.SS2.p1.7.m1.1.1.3.cmml">P</mi><mo id="Pt0.A1.SS2.p1.7.m1.1.1.2" xref="Pt0.A1.SS2.p1.7.m1.1.1.2.cmml">⁢</mo><mrow id="Pt0.A1.SS2.p1.7.m1.1.1.1.1" xref="Pt0.A1.SS2.p1.7.m1.1.1.1.2.cmml"><mo id="Pt0.A1.SS2.p1.7.m1.1.1.1.1.2" stretchy="false" xref="Pt0.A1.SS2.p1.7.m1.1.1.1.2.1.cmml">[</mo><mrow id="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1" xref="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1.cmml"><mi id="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1.2" xref="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1.2.cmml">i</mi><mo id="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1.1" xref="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1.1.cmml">−</mo><mn id="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1.3" xref="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1.3.cmml">1</mn></mrow><mo id="Pt0.A1.SS2.p1.7.m1.1.1.1.1.3" stretchy="false" xref="Pt0.A1.SS2.p1.7.m1.1.1.1.2.1.cmml">]</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p1.7.m1.1b"><apply id="Pt0.A1.SS2.p1.7.m1.1.1.cmml" xref="Pt0.A1.SS2.p1.7.m1.1.1"><times id="Pt0.A1.SS2.p1.7.m1.1.1.2.cmml" xref="Pt0.A1.SS2.p1.7.m1.1.1.2"></times><ci id="Pt0.A1.SS2.p1.7.m1.1.1.3.cmml" xref="Pt0.A1.SS2.p1.7.m1.1.1.3">𝑃</ci><apply id="Pt0.A1.SS2.p1.7.m1.1.1.1.2.cmml" xref="Pt0.A1.SS2.p1.7.m1.1.1.1.1"><csymbol cd="latexml" id="Pt0.A1.SS2.p1.7.m1.1.1.1.2.1.cmml" xref="Pt0.A1.SS2.p1.7.m1.1.1.1.1.2">delimited-[]</csymbol><apply id="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1.cmml" xref="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1"><minus id="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1.1.cmml" xref="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1.1"></minus><ci id="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1.2.cmml" xref="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1.2">𝑖</ci><cn id="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1.3.cmml" type="integer" xref="Pt0.A1.SS2.p1.7.m1.1.1.1.1.1.3">1</cn></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p1.7.m1.1c">P[i-1]</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p1.7.m1.1d">italic_P [ italic_i - 1 ]</annotation></semantics></math> and adding the incoming base <math alttext="P[i+k-1]" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p1.8.m2.1"><semantics id="Pt0.A1.SS2.p1.8.m2.1a"><mrow id="Pt0.A1.SS2.p1.8.m2.1.1" xref="Pt0.A1.SS2.p1.8.m2.1.1.cmml"><mi id="Pt0.A1.SS2.p1.8.m2.1.1.3" xref="Pt0.A1.SS2.p1.8.m2.1.1.3.cmml">P</mi><mo id="Pt0.A1.SS2.p1.8.m2.1.1.2" xref="Pt0.A1.SS2.p1.8.m2.1.1.2.cmml">⁢</mo><mrow id="Pt0.A1.SS2.p1.8.m2.1.1.1.1" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.2.cmml"><mo id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.2" stretchy="false" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.2.1.cmml">[</mo><mrow id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.cmml"><mrow id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2.cmml"><mi id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2.2" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2.2.cmml">i</mi><mo id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2.1" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2.1.cmml">+</mo><mi id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2.3" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2.3.cmml">k</mi></mrow><mo id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.1" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.1.cmml">−</mo><mn id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.3" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.3.cmml">1</mn></mrow><mo id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.3" stretchy="false" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.2.1.cmml">]</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p1.8.m2.1b"><apply id="Pt0.A1.SS2.p1.8.m2.1.1.cmml" xref="Pt0.A1.SS2.p1.8.m2.1.1"><times id="Pt0.A1.SS2.p1.8.m2.1.1.2.cmml" xref="Pt0.A1.SS2.p1.8.m2.1.1.2"></times><ci id="Pt0.A1.SS2.p1.8.m2.1.1.3.cmml" xref="Pt0.A1.SS2.p1.8.m2.1.1.3">𝑃</ci><apply id="Pt0.A1.SS2.p1.8.m2.1.1.1.2.cmml" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1"><csymbol cd="latexml" id="Pt0.A1.SS2.p1.8.m2.1.1.1.2.1.cmml" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.2">delimited-[]</csymbol><apply id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.cmml" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1"><minus id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.1.cmml" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.1"></minus><apply id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2.cmml" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2"><plus id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2.1.cmml" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2.1"></plus><ci id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2.2.cmml" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2.2">𝑖</ci><ci id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2.3.cmml" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.2.3">𝑘</ci></apply><cn id="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.3.cmml" type="integer" xref="Pt0.A1.SS2.p1.8.m2.1.1.1.1.1.3">1</cn></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p1.8.m2.1c">P[i+k-1]</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p1.8.m2.1d">italic_P [ italic_i + italic_k - 1 ]</annotation></semantics></math>. Let <math alttext="ror" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p1.9.m3.1"><semantics id="Pt0.A1.SS2.p1.9.m3.1a"><mrow id="Pt0.A1.SS2.p1.9.m3.1.1" xref="Pt0.A1.SS2.p1.9.m3.1.1.cmml"><mi id="Pt0.A1.SS2.p1.9.m3.1.1.2" xref="Pt0.A1.SS2.p1.9.m3.1.1.2.cmml">r</mi><mo id="Pt0.A1.SS2.p1.9.m3.1.1.1" xref="Pt0.A1.SS2.p1.9.m3.1.1.1.cmml">⁢</mo><mi id="Pt0.A1.SS2.p1.9.m3.1.1.3" xref="Pt0.A1.SS2.p1.9.m3.1.1.3.cmml">o</mi><mo id="Pt0.A1.SS2.p1.9.m3.1.1.1a" xref="Pt0.A1.SS2.p1.9.m3.1.1.1.cmml">⁢</mo><mi id="Pt0.A1.SS2.p1.9.m3.1.1.4" xref="Pt0.A1.SS2.p1.9.m3.1.1.4.cmml">r</mi></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p1.9.m3.1b"><apply id="Pt0.A1.SS2.p1.9.m3.1.1.cmml" xref="Pt0.A1.SS2.p1.9.m3.1.1"><times id="Pt0.A1.SS2.p1.9.m3.1.1.1.cmml" xref="Pt0.A1.SS2.p1.9.m3.1.1.1"></times><ci id="Pt0.A1.SS2.p1.9.m3.1.1.2.cmml" xref="Pt0.A1.SS2.p1.9.m3.1.1.2">𝑟</ci><ci id="Pt0.A1.SS2.p1.9.m3.1.1.3.cmml" xref="Pt0.A1.SS2.p1.9.m3.1.1.3">𝑜</ci><ci id="Pt0.A1.SS2.p1.9.m3.1.1.4.cmml" xref="Pt0.A1.SS2.p1.9.m3.1.1.4">𝑟</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p1.9.m3.1c">ror</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p1.9.m3.1d">italic_r italic_o italic_r</annotation></semantics></math> be binary cyclic right rotation and assume <math alttext="P_{c}[i]" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p1.10.m4.1"><semantics id="Pt0.A1.SS2.p1.10.m4.1a"><mrow id="Pt0.A1.SS2.p1.10.m4.1.2" xref="Pt0.A1.SS2.p1.10.m4.1.2.cmml"><msub id="Pt0.A1.SS2.p1.10.m4.1.2.2" xref="Pt0.A1.SS2.p1.10.m4.1.2.2.cmml"><mi id="Pt0.A1.SS2.p1.10.m4.1.2.2.2" xref="Pt0.A1.SS2.p1.10.m4.1.2.2.2.cmml">P</mi><mi id="Pt0.A1.SS2.p1.10.m4.1.2.2.3" xref="Pt0.A1.SS2.p1.10.m4.1.2.2.3.cmml">c</mi></msub><mo id="Pt0.A1.SS2.p1.10.m4.1.2.1" xref="Pt0.A1.SS2.p1.10.m4.1.2.1.cmml">⁢</mo><mrow id="Pt0.A1.SS2.p1.10.m4.1.2.3.2" xref="Pt0.A1.SS2.p1.10.m4.1.2.3.1.cmml"><mo id="Pt0.A1.SS2.p1.10.m4.1.2.3.2.1" stretchy="false" xref="Pt0.A1.SS2.p1.10.m4.1.2.3.1.1.cmml">[</mo><mi id="Pt0.A1.SS2.p1.10.m4.1.1" xref="Pt0.A1.SS2.p1.10.m4.1.1.cmml">i</mi><mo id="Pt0.A1.SS2.p1.10.m4.1.2.3.2.2" stretchy="false" xref="Pt0.A1.SS2.p1.10.m4.1.2.3.1.1.cmml">]</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p1.10.m4.1b"><apply id="Pt0.A1.SS2.p1.10.m4.1.2.cmml" xref="Pt0.A1.SS2.p1.10.m4.1.2"><times id="Pt0.A1.SS2.p1.10.m4.1.2.1.cmml" xref="Pt0.A1.SS2.p1.10.m4.1.2.1"></times><apply id="Pt0.A1.SS2.p1.10.m4.1.2.2.cmml" xref="Pt0.A1.SS2.p1.10.m4.1.2.2"><csymbol cd="ambiguous" id="Pt0.A1.SS2.p1.10.m4.1.2.2.1.cmml" xref="Pt0.A1.SS2.p1.10.m4.1.2.2">subscript</csymbol><ci id="Pt0.A1.SS2.p1.10.m4.1.2.2.2.cmml" xref="Pt0.A1.SS2.p1.10.m4.1.2.2.2">𝑃</ci><ci id="Pt0.A1.SS2.p1.10.m4.1.2.2.3.cmml" xref="Pt0.A1.SS2.p1.10.m4.1.2.2.3">𝑐</ci></apply><apply id="Pt0.A1.SS2.p1.10.m4.1.2.3.1.cmml" xref="Pt0.A1.SS2.p1.10.m4.1.2.3.2"><csymbol cd="latexml" id="Pt0.A1.SS2.p1.10.m4.1.2.3.1.1.cmml" xref="Pt0.A1.SS2.p1.10.m4.1.2.3.2.1">delimited-[]</csymbol><ci id="Pt0.A1.SS2.p1.10.m4.1.1.cmml" xref="Pt0.A1.SS2.p1.10.m4.1.1">𝑖</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p1.10.m4.1c">P_{c}[i]</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p1.10.m4.1d">italic_P start_POSTSUBSCRIPT italic_c end_POSTSUBSCRIPT [ italic_i ]</annotation></semantics></math> is the seed for the corresponding complement of the base at <math alttext="P[i]" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p1.11.m5.1"><semantics id="Pt0.A1.SS2.p1.11.m5.1a"><mrow id="Pt0.A1.SS2.p1.11.m5.1.2" xref="Pt0.A1.SS2.p1.11.m5.1.2.cmml"><mi id="Pt0.A1.SS2.p1.11.m5.1.2.2" xref="Pt0.A1.SS2.p1.11.m5.1.2.2.cmml">P</mi><mo id="Pt0.A1.SS2.p1.11.m5.1.2.1" xref="Pt0.A1.SS2.p1.11.m5.1.2.1.cmml">⁢</mo><mrow id="Pt0.A1.SS2.p1.11.m5.1.2.3.2" xref="Pt0.A1.SS2.p1.11.m5.1.2.3.1.cmml"><mo id="Pt0.A1.SS2.p1.11.m5.1.2.3.2.1" stretchy="false" xref="Pt0.A1.SS2.p1.11.m5.1.2.3.1.1.cmml">[</mo><mi id="Pt0.A1.SS2.p1.11.m5.1.1" xref="Pt0.A1.SS2.p1.11.m5.1.1.cmml">i</mi><mo id="Pt0.A1.SS2.p1.11.m5.1.2.3.2.2" stretchy="false" xref="Pt0.A1.SS2.p1.11.m5.1.2.3.1.1.cmml">]</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p1.11.m5.1b"><apply id="Pt0.A1.SS2.p1.11.m5.1.2.cmml" xref="Pt0.A1.SS2.p1.11.m5.1.2"><times id="Pt0.A1.SS2.p1.11.m5.1.2.1.cmml" xref="Pt0.A1.SS2.p1.11.m5.1.2.1"></times><ci id="Pt0.A1.SS2.p1.11.m5.1.2.2.cmml" xref="Pt0.A1.SS2.p1.11.m5.1.2.2">𝑃</ci><apply id="Pt0.A1.SS2.p1.11.m5.1.2.3.1.cmml" xref="Pt0.A1.SS2.p1.11.m5.1.2.3.2"><csymbol cd="latexml" id="Pt0.A1.SS2.p1.11.m5.1.2.3.1.1.cmml" xref="Pt0.A1.SS2.p1.11.m5.1.2.3.2.1">delimited-[]</csymbol><ci id="Pt0.A1.SS2.p1.11.m5.1.1.cmml" xref="Pt0.A1.SS2.p1.11.m5.1.1">𝑖</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p1.11.m5.1c">P[i]</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p1.11.m5.1d">italic_P [ italic_i ]</annotation></semantics></math>. The analogous operations for the reverse complement are</p>
<table class="ltx_equation ltx_eqn_table" id="Pt0.A1.Ex3">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="H_{rc}(P[0..k-1])=P_{c}[0]\oplus rol(P_{c}[1])\oplus rol^{2}(P_{c}[2])\oplus..%
.\oplus rol^{k-1}P_{c}[k-1]" class="ltx_math_unparsed" display="block" id="Pt0.A1.Ex3.m1.1"><semantics id="Pt0.A1.Ex3.m1.1a"><mrow id="Pt0.A1.Ex3.m1.1b"><msub id="Pt0.A1.Ex3.m1.1.1"><mi id="Pt0.A1.Ex3.m1.1.1.2" mathsize="90%">H</mi><mrow id="Pt0.A1.Ex3.m1.1.1.3"><mi id="Pt0.A1.Ex3.m1.1.1.3.2" mathsize="90%">r</mi><mo id="Pt0.A1.Ex3.m1.1.1.3.1">⁢</mo><mi id="Pt0.A1.Ex3.m1.1.1.3.3" mathsize="90%">c</mi></mrow></msub><mrow id="Pt0.A1.Ex3.m1.1.2"><mo id="Pt0.A1.Ex3.m1.1.2.1" maxsize="90%" minsize="90%">(</mo><mi id="Pt0.A1.Ex3.m1.1.2.2" mathsize="90%">P</mi><mrow id="Pt0.A1.Ex3.m1.1.2.3"><mo id="Pt0.A1.Ex3.m1.1.2.3.1" maxsize="90%" minsize="90%">[</mo><mn id="Pt0.A1.Ex3.m1.1.2.3.2" mathsize="90%">0</mn><mo id="Pt0.A1.Ex3.m1.1.2.3.3" lspace="0em" mathsize="90%" rspace="0.0835em">.</mo><mo id="Pt0.A1.Ex3.m1.1.2.3.4" lspace="0.0835em" mathsize="90%" rspace="0.167em">.</mo><mi id="Pt0.A1.Ex3.m1.1.2.3.5" mathsize="90%">k</mi><mo id="Pt0.A1.Ex3.m1.1.2.3.6" mathsize="90%">−</mo><mn id="Pt0.A1.Ex3.m1.1.2.3.7" mathsize="90%">1</mn><mo id="Pt0.A1.Ex3.m1.1.2.3.8" maxsize="90%" minsize="90%">]</mo></mrow><mo id="Pt0.A1.Ex3.m1.1.2.4" maxsize="90%" minsize="90%">)</mo></mrow><mo id="Pt0.A1.Ex3.m1.1.3" mathsize="90%">=</mo><msub id="Pt0.A1.Ex3.m1.1.4"><mi id="Pt0.A1.Ex3.m1.1.4.2" mathsize="90%">P</mi><mi id="Pt0.A1.Ex3.m1.1.4.3" mathsize="90%">c</mi></msub><mrow id="Pt0.A1.Ex3.m1.1.5"><mo id="Pt0.A1.Ex3.m1.1.5.1" maxsize="90%" minsize="90%">[</mo><mn id="Pt0.A1.Ex3.m1.1.5.2" mathsize="90%">0</mn><mo id="Pt0.A1.Ex3.m1.1.5.3" maxsize="90%" minsize="90%">]</mo></mrow><mo id="Pt0.A1.Ex3.m1.1.6" mathsize="90%">⊕</mo><mi id="Pt0.A1.Ex3.m1.1.7" mathsize="90%">r</mi><mi id="Pt0.A1.Ex3.m1.1.8" mathsize="90%">o</mi><mi id="Pt0.A1.Ex3.m1.1.9" mathsize="90%">l</mi><mrow id="Pt0.A1.Ex3.m1.1.10"><mo id="Pt0.A1.Ex3.m1.1.10.1" maxsize="90%" minsize="90%">(</mo><msub id="Pt0.A1.Ex3.m1.1.10.2"><mi id="Pt0.A1.Ex3.m1.1.10.2.2" mathsize="90%">P</mi><mi id="Pt0.A1.Ex3.m1.1.10.2.3" mathsize="90%">c</mi></msub><mrow id="Pt0.A1.Ex3.m1.1.10.3"><mo id="Pt0.A1.Ex3.m1.1.10.3.1" maxsize="90%" minsize="90%">[</mo><mn id="Pt0.A1.Ex3.m1.1.10.3.2" mathsize="90%">1</mn><mo id="Pt0.A1.Ex3.m1.1.10.3.3" maxsize="90%" minsize="90%">]</mo></mrow><mo id="Pt0.A1.Ex3.m1.1.10.4" maxsize="90%" minsize="90%">)</mo></mrow><mo id="Pt0.A1.Ex3.m1.1.11" mathsize="90%">⊕</mo><mi id="Pt0.A1.Ex3.m1.1.12" mathsize="90%">r</mi><mi id="Pt0.A1.Ex3.m1.1.13" mathsize="90%">o</mi><msup id="Pt0.A1.Ex3.m1.1.14"><mi id="Pt0.A1.Ex3.m1.1.14.2" mathsize="90%">l</mi><mn id="Pt0.A1.Ex3.m1.1.14.3" mathsize="90%">2</mn></msup><mrow id="Pt0.A1.Ex3.m1.1.15"><mo id="Pt0.A1.Ex3.m1.1.15.1" maxsize="90%" minsize="90%">(</mo><msub id="Pt0.A1.Ex3.m1.1.15.2"><mi id="Pt0.A1.Ex3.m1.1.15.2.2" mathsize="90%">P</mi><mi id="Pt0.A1.Ex3.m1.1.15.2.3" mathsize="90%">c</mi></msub><mrow id="Pt0.A1.Ex3.m1.1.15.3"><mo id="Pt0.A1.Ex3.m1.1.15.3.1" maxsize="90%" minsize="90%">[</mo><mn id="Pt0.A1.Ex3.m1.1.15.3.2" mathsize="90%">2</mn><mo id="Pt0.A1.Ex3.m1.1.15.3.3" maxsize="90%" minsize="90%">]</mo></mrow><mo id="Pt0.A1.Ex3.m1.1.15.4" maxsize="90%" minsize="90%">)</mo></mrow><mo id="Pt0.A1.Ex3.m1.1.16" mathsize="90%">⊕</mo><mi id="Pt0.A1.Ex3.m1.1.17" mathsize="90%" mathvariant="normal">…</mi><mo id="Pt0.A1.Ex3.m1.1.18" mathsize="90%">⊕</mo><mi id="Pt0.A1.Ex3.m1.1.19" mathsize="90%">r</mi><mi id="Pt0.A1.Ex3.m1.1.20" mathsize="90%">o</mi><msup id="Pt0.A1.Ex3.m1.1.21"><mi id="Pt0.A1.Ex3.m1.1.21.2" mathsize="90%">l</mi><mrow id="Pt0.A1.Ex3.m1.1.21.3"><mi id="Pt0.A1.Ex3.m1.1.21.3.2" mathsize="90%">k</mi><mo id="Pt0.A1.Ex3.m1.1.21.3.1" mathsize="90%">−</mo><mn id="Pt0.A1.Ex3.m1.1.21.3.3" mathsize="90%">1</mn></mrow></msup><msub id="Pt0.A1.Ex3.m1.1.22"><mi id="Pt0.A1.Ex3.m1.1.22.2" mathsize="90%">P</mi><mi id="Pt0.A1.Ex3.m1.1.22.3" mathsize="90%">c</mi></msub><mrow id="Pt0.A1.Ex3.m1.1.23"><mo id="Pt0.A1.Ex3.m1.1.23.1" maxsize="90%" minsize="90%">[</mo><mi id="Pt0.A1.Ex3.m1.1.23.2" mathsize="90%">k</mi><mo id="Pt0.A1.Ex3.m1.1.23.3" mathsize="90%">−</mo><mn id="Pt0.A1.Ex3.m1.1.23.4" mathsize="90%">1</mn><mo id="Pt0.A1.Ex3.m1.1.23.5" maxsize="90%" minsize="90%">]</mo></mrow></mrow><annotation encoding="application/x-tex" id="Pt0.A1.Ex3.m1.1c">H_{rc}(P[0..k-1])=P_{c}[0]\oplus rol(P_{c}[1])\oplus rol^{2}(P_{c}[2])\oplus..%
.\oplus rol^{k-1}P_{c}[k-1]</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.Ex3.m1.1d">italic_H start_POSTSUBSCRIPT italic_r italic_c end_POSTSUBSCRIPT ( italic_P [ 0 . . italic_k - 1 ] ) = italic_P start_POSTSUBSCRIPT italic_c end_POSTSUBSCRIPT [ 0 ] ⊕ italic_r italic_o italic_l ( italic_P start_POSTSUBSCRIPT italic_c end_POSTSUBSCRIPT [ 1 ] ) ⊕ italic_r italic_o italic_l start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_P start_POSTSUBSCRIPT italic_c end_POSTSUBSCRIPT [ 2 ] ) ⊕ … ⊕ italic_r italic_o italic_l start_POSTSUPERSCRIPT italic_k - 1 end_POSTSUPERSCRIPT italic_P start_POSTSUBSCRIPT italic_c end_POSTSUBSCRIPT [ italic_k - 1 ]</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p class="ltx_p" id="Pt0.A1.SS2.p1.12">with subsequent hashes computed as</p>
<table class="ltx_equation ltx_eqn_table" id="Pt0.A1.Ex4">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="H_{rc}(P[i..i+k-1])=ror\!\left(H_{rc}(P[i-1..i+k-2])\oplus P_{c}[i-1]\oplus rol%
^{k}(P_{c}[i+k-1])\right)." class="ltx_math_unparsed" display="block" id="Pt0.A1.Ex4.m1.1"><semantics id="Pt0.A1.Ex4.m1.1a"><mrow id="Pt0.A1.Ex4.m1.1b"><msub id="Pt0.A1.Ex4.m1.1.1"><mi id="Pt0.A1.Ex4.m1.1.1.2" mathsize="90%">H</mi><mrow id="Pt0.A1.Ex4.m1.1.1.3"><mi id="Pt0.A1.Ex4.m1.1.1.3.2" mathsize="90%">r</mi><mo id="Pt0.A1.Ex4.m1.1.1.3.1">⁢</mo><mi id="Pt0.A1.Ex4.m1.1.1.3.3" mathsize="90%">c</mi></mrow></msub><mrow id="Pt0.A1.Ex4.m1.1.2"><mo id="Pt0.A1.Ex4.m1.1.2.1" maxsize="90%" minsize="90%">(</mo><mi id="Pt0.A1.Ex4.m1.1.2.2" mathsize="90%">P</mi><mrow id="Pt0.A1.Ex4.m1.1.2.3"><mo id="Pt0.A1.Ex4.m1.1.2.3.1" maxsize="90%" minsize="90%">[</mo><mi id="Pt0.A1.Ex4.m1.1.2.3.2" mathsize="90%">i</mi><mo id="Pt0.A1.Ex4.m1.1.2.3.3" lspace="0em" mathsize="90%" rspace="0.0835em">.</mo><mo id="Pt0.A1.Ex4.m1.1.2.3.4" lspace="0.0835em" mathsize="90%" rspace="0.167em">.</mo><mi id="Pt0.A1.Ex4.m1.1.2.3.5" mathsize="90%">i</mi><mo id="Pt0.A1.Ex4.m1.1.2.3.6" mathsize="90%">+</mo><mi id="Pt0.A1.Ex4.m1.1.2.3.7" mathsize="90%">k</mi><mo id="Pt0.A1.Ex4.m1.1.2.3.8" mathsize="90%">−</mo><mn id="Pt0.A1.Ex4.m1.1.2.3.9" mathsize="90%">1</mn><mo id="Pt0.A1.Ex4.m1.1.2.3.10" maxsize="90%" minsize="90%">]</mo></mrow><mo id="Pt0.A1.Ex4.m1.1.2.4" maxsize="90%" minsize="90%">)</mo></mrow><mo id="Pt0.A1.Ex4.m1.1.3" mathsize="90%">=</mo><mi id="Pt0.A1.Ex4.m1.1.4" mathsize="90%">r</mi><mi id="Pt0.A1.Ex4.m1.1.5" mathsize="90%">o</mi><mpadded id="Pt0.A1.Ex4.m1.1c" width="0.309em"><mi id="Pt0.A1.Ex4.m1.1.6" mathsize="90%">r</mi></mpadded><mrow id="Pt0.A1.Ex4.m1.1.7"><mo id="Pt0.A1.Ex4.m1.1.7.1">(</mo><msub id="Pt0.A1.Ex4.m1.1.7.2"><mi id="Pt0.A1.Ex4.m1.1.7.2.2" mathsize="90%">H</mi><mrow id="Pt0.A1.Ex4.m1.1.7.2.3"><mi id="Pt0.A1.Ex4.m1.1.7.2.3.2" mathsize="90%">r</mi><mo id="Pt0.A1.Ex4.m1.1.7.2.3.1">⁢</mo><mi id="Pt0.A1.Ex4.m1.1.7.2.3.3" mathsize="90%">c</mi></mrow></msub><mrow id="Pt0.A1.Ex4.m1.1.7.3"><mo id="Pt0.A1.Ex4.m1.1.7.3.1" maxsize="90%" minsize="90%">(</mo><mi id="Pt0.A1.Ex4.m1.1.7.3.2" mathsize="90%">P</mi><mrow id="Pt0.A1.Ex4.m1.1.7.3.3"><mo id="Pt0.A1.Ex4.m1.1.7.3.3.1" maxsize="90%" minsize="90%">[</mo><mi id="Pt0.A1.Ex4.m1.1.7.3.3.2" mathsize="90%">i</mi><mo id="Pt0.A1.Ex4.m1.1.7.3.3.3" mathsize="90%">−</mo><mn id="Pt0.A1.Ex4.m1.1.7.3.3.4" mathsize="90%">1</mn><mo id="Pt0.A1.Ex4.m1.1.7.3.3.5" lspace="0em" mathsize="90%" rspace="0.0835em">.</mo><mo id="Pt0.A1.Ex4.m1.1.7.3.3.6" lspace="0.0835em" mathsize="90%" rspace="0.167em">.</mo><mi id="Pt0.A1.Ex4.m1.1.7.3.3.7" mathsize="90%">i</mi><mo id="Pt0.A1.Ex4.m1.1.7.3.3.8" mathsize="90%">+</mo><mi id="Pt0.A1.Ex4.m1.1.7.3.3.9" mathsize="90%">k</mi><mo id="Pt0.A1.Ex4.m1.1.7.3.3.10" mathsize="90%">−</mo><mn id="Pt0.A1.Ex4.m1.1.7.3.3.11" mathsize="90%">2</mn><mo id="Pt0.A1.Ex4.m1.1.7.3.3.12" maxsize="90%" minsize="90%">]</mo></mrow><mo id="Pt0.A1.Ex4.m1.1.7.3.4" maxsize="90%" minsize="90%">)</mo></mrow><mo id="Pt0.A1.Ex4.m1.1.7.4" mathsize="90%">⊕</mo><msub id="Pt0.A1.Ex4.m1.1.7.5"><mi id="Pt0.A1.Ex4.m1.1.7.5.2" mathsize="90%">P</mi><mi id="Pt0.A1.Ex4.m1.1.7.5.3" mathsize="90%">c</mi></msub><mrow id="Pt0.A1.Ex4.m1.1.7.6"><mo id="Pt0.A1.Ex4.m1.1.7.6.1" maxsize="90%" minsize="90%">[</mo><mi id="Pt0.A1.Ex4.m1.1.7.6.2" mathsize="90%">i</mi><mo id="Pt0.A1.Ex4.m1.1.7.6.3" mathsize="90%">−</mo><mn id="Pt0.A1.Ex4.m1.1.7.6.4" mathsize="90%">1</mn><mo id="Pt0.A1.Ex4.m1.1.7.6.5" maxsize="90%" minsize="90%">]</mo></mrow><mo id="Pt0.A1.Ex4.m1.1.7.7" mathsize="90%">⊕</mo><mi id="Pt0.A1.Ex4.m1.1.7.8" mathsize="90%">r</mi><mi id="Pt0.A1.Ex4.m1.1.7.9" mathsize="90%">o</mi><msup id="Pt0.A1.Ex4.m1.1.7.10"><mi id="Pt0.A1.Ex4.m1.1.7.10.2" mathsize="90%">l</mi><mi id="Pt0.A1.Ex4.m1.1.7.10.3" mathsize="90%">k</mi></msup><mrow id="Pt0.A1.Ex4.m1.1.7.11"><mo id="Pt0.A1.Ex4.m1.1.7.11.1" maxsize="90%" minsize="90%">(</mo><msub id="Pt0.A1.Ex4.m1.1.7.11.2"><mi id="Pt0.A1.Ex4.m1.1.7.11.2.2" mathsize="90%">P</mi><mi id="Pt0.A1.Ex4.m1.1.7.11.2.3" mathsize="90%">c</mi></msub><mrow id="Pt0.A1.Ex4.m1.1.7.11.3"><mo id="Pt0.A1.Ex4.m1.1.7.11.3.1" maxsize="90%" minsize="90%">[</mo><mi id="Pt0.A1.Ex4.m1.1.7.11.3.2" mathsize="90%">i</mi><mo id="Pt0.A1.Ex4.m1.1.7.11.3.3" mathsize="90%">+</mo><mi id="Pt0.A1.Ex4.m1.1.7.11.3.4" mathsize="90%">k</mi><mo id="Pt0.A1.Ex4.m1.1.7.11.3.5" mathsize="90%">−</mo><mn id="Pt0.A1.Ex4.m1.1.7.11.3.6" mathsize="90%">1</mn><mo id="Pt0.A1.Ex4.m1.1.7.11.3.7" maxsize="90%" minsize="90%">]</mo></mrow><mo id="Pt0.A1.Ex4.m1.1.7.11.4" maxsize="90%" minsize="90%">)</mo></mrow><mo id="Pt0.A1.Ex4.m1.1.7.12">)</mo></mrow><mo id="Pt0.A1.Ex4.m1.1.8" lspace="0em" mathsize="90%">.</mo></mrow><annotation encoding="application/x-tex" id="Pt0.A1.Ex4.m1.1d">H_{rc}(P[i..i+k-1])=ror\!\left(H_{rc}(P[i-1..i+k-2])\oplus P_{c}[i-1]\oplus rol%
^{k}(P_{c}[i+k-1])\right).</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.Ex4.m1.1e">italic_H start_POSTSUBSCRIPT italic_r italic_c end_POSTSUBSCRIPT ( italic_P [ italic_i . . italic_i + italic_k - 1 ] ) = italic_r italic_o italic_r ( italic_H start_POSTSUBSCRIPT italic_r italic_c end_POSTSUBSCRIPT ( italic_P [ italic_i - 1 . . italic_i + italic_k - 2 ] ) ⊕ italic_P start_POSTSUBSCRIPT italic_c end_POSTSUBSCRIPT [ italic_i - 1 ] ⊕ italic_r italic_o italic_l start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ( italic_P start_POSTSUBSCRIPT italic_c end_POSTSUBSCRIPT [ italic_i + italic_k - 1 ] ) ) .</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
</div>
<div class="ltx_para" id="Pt0.A1.SS2.p2">
<p class="ltx_p" id="Pt0.A1.SS2.p2.8">Notice that, given <math alttext="k" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p2.1.m1.1"><semantics id="Pt0.A1.SS2.p2.1.m1.1a"><mi id="Pt0.A1.SS2.p2.1.m1.1.1" xref="Pt0.A1.SS2.p2.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p2.1.m1.1b"><ci id="Pt0.A1.SS2.p2.1.m1.1.1.cmml" xref="Pt0.A1.SS2.p2.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p2.1.m1.1c">k</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p2.1.m1.1d">italic_k</annotation></semantics></math>, the <math alttext="rol^{k}" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p2.2.m2.1"><semantics id="Pt0.A1.SS2.p2.2.m2.1a"><mrow id="Pt0.A1.SS2.p2.2.m2.1.1" xref="Pt0.A1.SS2.p2.2.m2.1.1.cmml"><mi id="Pt0.A1.SS2.p2.2.m2.1.1.2" xref="Pt0.A1.SS2.p2.2.m2.1.1.2.cmml">r</mi><mo id="Pt0.A1.SS2.p2.2.m2.1.1.1" xref="Pt0.A1.SS2.p2.2.m2.1.1.1.cmml">⁢</mo><mi id="Pt0.A1.SS2.p2.2.m2.1.1.3" xref="Pt0.A1.SS2.p2.2.m2.1.1.3.cmml">o</mi><mo id="Pt0.A1.SS2.p2.2.m2.1.1.1a" xref="Pt0.A1.SS2.p2.2.m2.1.1.1.cmml">⁢</mo><msup id="Pt0.A1.SS2.p2.2.m2.1.1.4" xref="Pt0.A1.SS2.p2.2.m2.1.1.4.cmml"><mi id="Pt0.A1.SS2.p2.2.m2.1.1.4.2" xref="Pt0.A1.SS2.p2.2.m2.1.1.4.2.cmml">l</mi><mi id="Pt0.A1.SS2.p2.2.m2.1.1.4.3" xref="Pt0.A1.SS2.p2.2.m2.1.1.4.3.cmml">k</mi></msup></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p2.2.m2.1b"><apply id="Pt0.A1.SS2.p2.2.m2.1.1.cmml" xref="Pt0.A1.SS2.p2.2.m2.1.1"><times id="Pt0.A1.SS2.p2.2.m2.1.1.1.cmml" xref="Pt0.A1.SS2.p2.2.m2.1.1.1"></times><ci id="Pt0.A1.SS2.p2.2.m2.1.1.2.cmml" xref="Pt0.A1.SS2.p2.2.m2.1.1.2">𝑟</ci><ci id="Pt0.A1.SS2.p2.2.m2.1.1.3.cmml" xref="Pt0.A1.SS2.p2.2.m2.1.1.3">𝑜</ci><apply id="Pt0.A1.SS2.p2.2.m2.1.1.4.cmml" xref="Pt0.A1.SS2.p2.2.m2.1.1.4"><csymbol cd="ambiguous" id="Pt0.A1.SS2.p2.2.m2.1.1.4.1.cmml" xref="Pt0.A1.SS2.p2.2.m2.1.1.4">superscript</csymbol><ci id="Pt0.A1.SS2.p2.2.m2.1.1.4.2.cmml" xref="Pt0.A1.SS2.p2.2.m2.1.1.4.2">𝑙</ci><ci id="Pt0.A1.SS2.p2.2.m2.1.1.4.3.cmml" xref="Pt0.A1.SS2.p2.2.m2.1.1.4.3">𝑘</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p2.2.m2.1c">rol^{k}</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p2.2.m2.1d">italic_r italic_o italic_l start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT</annotation></semantics></math> operations required to find the next <math alttext="k" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p2.3.m3.1"><semantics id="Pt0.A1.SS2.p2.3.m3.1a"><mi id="Pt0.A1.SS2.p2.3.m3.1.1" xref="Pt0.A1.SS2.p2.3.m3.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p2.3.m3.1b"><ci id="Pt0.A1.SS2.p2.3.m3.1.1.cmml" xref="Pt0.A1.SS2.p2.3.m3.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p2.3.m3.1c">k</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p2.3.m3.1d">italic_k</annotation></semantics></math>-mer hash for both the forward and reverse complement can be precomputed for each base. The original ntHash paper does something similar but requires more computation to allow for flexible <math alttext="k" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p2.4.m4.1"><semantics id="Pt0.A1.SS2.p2.4.m4.1a"><mi id="Pt0.A1.SS2.p2.4.m4.1.1" xref="Pt0.A1.SS2.p2.4.m4.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p2.4.m4.1b"><ci id="Pt0.A1.SS2.p2.4.m4.1.1.cmml" xref="Pt0.A1.SS2.p2.4.m4.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p2.4.m4.1c">k</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p2.4.m4.1d">italic_k</annotation></semantics></math>; since our <math alttext="k" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p2.5.m5.1"><semantics id="Pt0.A1.SS2.p2.5.m5.1a"><mi id="Pt0.A1.SS2.p2.5.m5.1.1" xref="Pt0.A1.SS2.p2.5.m5.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p2.5.m5.1b"><ci id="Pt0.A1.SS2.p2.5.m5.1.1.cmml" xref="Pt0.A1.SS2.p2.5.m5.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p2.5.m5.1c">k</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p2.5.m5.1d">italic_k</annotation></semantics></math> is fixed at construction time we explicitly precompute these lookup tables as well as tables for the seeds of bases and their reverse complements. This approach allows us to compute the hash value, for both the forward and reverse complement strands, of all <math alttext="k" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p2.6.m6.1"><semantics id="Pt0.A1.SS2.p2.6.m6.1a"><mi id="Pt0.A1.SS2.p2.6.m6.1.1" xref="Pt0.A1.SS2.p2.6.m6.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p2.6.m6.1b"><ci id="Pt0.A1.SS2.p2.6.m6.1.1.cmml" xref="Pt0.A1.SS2.p2.6.m6.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p2.6.m6.1c">k</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p2.6.m6.1d">italic_k</annotation></semantics></math>-mers by extending the previous using only lookups, XORs and a single <math alttext="rol" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p2.7.m7.1"><semantics id="Pt0.A1.SS2.p2.7.m7.1a"><mrow id="Pt0.A1.SS2.p2.7.m7.1.1" xref="Pt0.A1.SS2.p2.7.m7.1.1.cmml"><mi id="Pt0.A1.SS2.p2.7.m7.1.1.2" xref="Pt0.A1.SS2.p2.7.m7.1.1.2.cmml">r</mi><mo id="Pt0.A1.SS2.p2.7.m7.1.1.1" xref="Pt0.A1.SS2.p2.7.m7.1.1.1.cmml">⁢</mo><mi id="Pt0.A1.SS2.p2.7.m7.1.1.3" xref="Pt0.A1.SS2.p2.7.m7.1.1.3.cmml">o</mi><mo id="Pt0.A1.SS2.p2.7.m7.1.1.1a" xref="Pt0.A1.SS2.p2.7.m7.1.1.1.cmml">⁢</mo><mi id="Pt0.A1.SS2.p2.7.m7.1.1.4" xref="Pt0.A1.SS2.p2.7.m7.1.1.4.cmml">l</mi></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p2.7.m7.1b"><apply id="Pt0.A1.SS2.p2.7.m7.1.1.cmml" xref="Pt0.A1.SS2.p2.7.m7.1.1"><times id="Pt0.A1.SS2.p2.7.m7.1.1.1.cmml" xref="Pt0.A1.SS2.p2.7.m7.1.1.1"></times><ci id="Pt0.A1.SS2.p2.7.m7.1.1.2.cmml" xref="Pt0.A1.SS2.p2.7.m7.1.1.2">𝑟</ci><ci id="Pt0.A1.SS2.p2.7.m7.1.1.3.cmml" xref="Pt0.A1.SS2.p2.7.m7.1.1.3">𝑜</ci><ci id="Pt0.A1.SS2.p2.7.m7.1.1.4.cmml" xref="Pt0.A1.SS2.p2.7.m7.1.1.4">𝑙</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p2.7.m7.1c">rol</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p2.7.m7.1d">italic_r italic_o italic_l</annotation></semantics></math> or <math alttext="ror" class="ltx_Math" display="inline" id="Pt0.A1.SS2.p2.8.m8.1"><semantics id="Pt0.A1.SS2.p2.8.m8.1a"><mrow id="Pt0.A1.SS2.p2.8.m8.1.1" xref="Pt0.A1.SS2.p2.8.m8.1.1.cmml"><mi id="Pt0.A1.SS2.p2.8.m8.1.1.2" xref="Pt0.A1.SS2.p2.8.m8.1.1.2.cmml">r</mi><mo id="Pt0.A1.SS2.p2.8.m8.1.1.1" xref="Pt0.A1.SS2.p2.8.m8.1.1.1.cmml">⁢</mo><mi id="Pt0.A1.SS2.p2.8.m8.1.1.3" xref="Pt0.A1.SS2.p2.8.m8.1.1.3.cmml">o</mi><mo id="Pt0.A1.SS2.p2.8.m8.1.1.1a" xref="Pt0.A1.SS2.p2.8.m8.1.1.1.cmml">⁢</mo><mi id="Pt0.A1.SS2.p2.8.m8.1.1.4" xref="Pt0.A1.SS2.p2.8.m8.1.1.4.cmml">r</mi></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS2.p2.8.m8.1b"><apply id="Pt0.A1.SS2.p2.8.m8.1.1.cmml" xref="Pt0.A1.SS2.p2.8.m8.1.1"><times id="Pt0.A1.SS2.p2.8.m8.1.1.1.cmml" xref="Pt0.A1.SS2.p2.8.m8.1.1.1"></times><ci id="Pt0.A1.SS2.p2.8.m8.1.1.2.cmml" xref="Pt0.A1.SS2.p2.8.m8.1.1.2">𝑟</ci><ci id="Pt0.A1.SS2.p2.8.m8.1.1.3.cmml" xref="Pt0.A1.SS2.p2.8.m8.1.1.3">𝑜</ci><ci id="Pt0.A1.SS2.p2.8.m8.1.1.4.cmml" xref="Pt0.A1.SS2.p2.8.m8.1.1.4">𝑟</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS2.p2.8.m8.1c">ror</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS2.p2.8.m8.1d">italic_r italic_o italic_r</annotation></semantics></math> operation; we compute all hashes in linear time and fast in practice.</p>
</div>
</section>
<section class="ltx_subsection" id="Pt0.A1.SS3">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">0.A.3 </span>Latency hiding and parallelization</h3>
<div class="ltx_para" id="Pt0.A1.SS3.p1">
<p class="ltx_p" id="Pt0.A1.SS3.p1.2"><span class="ltx_text ltx_font_italic" id="Pt0.A1.SS3.p1.2.1">Latency hiding</span> avoids the time taken to load a memory word of the Bloom filter into cache by performing concurrent operations. Our approach uses it during queries by assuming a prefetch distance, set to <math alttext="32" class="ltx_Math" display="inline" id="Pt0.A1.SS3.p1.1.m1.1"><semantics id="Pt0.A1.SS3.p1.1.m1.1a"><mn id="Pt0.A1.SS3.p1.1.m1.1.1" xref="Pt0.A1.SS3.p1.1.m1.1.1.cmml">32</mn><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS3.p1.1.m1.1b"><cn id="Pt0.A1.SS3.p1.1.m1.1.1.cmml" type="integer" xref="Pt0.A1.SS3.p1.1.m1.1.1">32</cn></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS3.p1.1.m1.1c">32</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS3.p1.1.m1.1d">32</annotation></semantics></math>, of how many filter words we ask the CPU to fetch into memory before reading them during computation. During that time, we continue processing other hash functions/<math alttext="k" class="ltx_Math" display="inline" id="Pt0.A1.SS3.p1.2.m2.1"><semantics id="Pt0.A1.SS3.p1.2.m2.1a"><mi id="Pt0.A1.SS3.p1.2.m2.1.1" xref="Pt0.A1.SS3.p1.2.m2.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="Pt0.A1.SS3.p1.2.m2.1b"><ci id="Pt0.A1.SS3.p1.2.m2.1.1.cmml" xref="Pt0.A1.SS3.p1.2.m2.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A1.SS3.p1.2.m2.1c">k</annotation><annotation encoding="application/x-llamapun" id="Pt0.A1.SS3.p1.2.m2.1d">italic_k</annotation></semantics></math>-mers to find which words those require before going back to read the Bloom filter bits of queries now in cache and returning their responses.</p>
</div>
<div class="ltx_para" id="Pt0.A1.SS3.p2">
<p class="ltx_p" id="Pt0.A1.SS3.p2.1">We also <span class="ltx_text ltx_font_italic" id="Pt0.A1.SS3.p2.1.1">parallelize</span> on a number of threads, giving each one read to perform concurrent operations for insertion/querying. This can change the order of when each read has its pseudo-MEMs output, but not the order of pseudo-MEMs within a read since only one thread writes at a time.</p>
</div>
</section>
</section>
<section class="ltx_appendix" id="Pt0.A2">
<h2 class="ltx_title ltx_title_appendix">
<span class="ltx_tag ltx_tag_appendix">Appendix 0.B </span>Technical details</h2>
<section class="ltx_subsection" id="Pt0.A2.SS1">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">0.B.1 </span>Experiments</h3>
<div class="ltx_para" id="Pt0.A2.SS1.p1">
<p class="ltx_p" id="Pt0.A2.SS1.p1.1">Timings reported in Figures <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4.F2" title="Figure 2 ‣ 4.1 MEM-finding ‣ 4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">2</span></a> and <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4.F3" title="Figure 3 ‣ 4.1 MEM-finding ‣ 4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">3</span></a> were measured using <span class="ltx_text ltx_font_typewriter" id="Pt0.A2.SS1.p1.1.1">GNU</span> time on a server with an Intel(R) Xeon(R) Gold 6248R CPU running at 3.00 GHz with 48 cores and 1.5TB DDR4 memory, averaged over 10 runs using <math alttext="16" class="ltx_Math" display="inline" id="Pt0.A2.SS1.p1.1.m1.1"><semantics id="Pt0.A2.SS1.p1.1.m1.1a"><mn id="Pt0.A2.SS1.p1.1.m1.1.1" xref="Pt0.A2.SS1.p1.1.m1.1.1.cmml">16</mn><annotation-xml encoding="MathML-Content" id="Pt0.A2.SS1.p1.1.m1.1b"><cn id="Pt0.A2.SS1.p1.1.m1.1.1.cmml" type="integer" xref="Pt0.A2.SS1.p1.1.m1.1.1">16</cn></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A2.SS1.p1.1.m1.1c">16</annotation><annotation encoding="application/x-llamapun" id="Pt0.A2.SS1.p1.1.m1.1d">16</annotation></semantics></math> threads. Timings reported in Figure <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4.F5" title="Figure 5 ‣ 4.2 Metagenomic Classification ‣ 4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">5</span></a> were measured using <span class="ltx_text ltx_font_typewriter" id="Pt0.A2.SS1.p1.1.2">GNU</span> time on a server with an Intel(R) Xeon(R) E5-2698 v3 CPU running at 2.30 GHz with 32 cores (two threads per core) and 270 GB memory, using a single thread.</p>
</div>
<div class="ltx_para" id="Pt0.A2.SS1.p2">
<p class="ltx_p" id="Pt0.A2.SS1.p2.5">Estimating <math alttext="k" class="ltx_Math" display="inline" id="Pt0.A2.SS1.p2.1.m1.1"><semantics id="Pt0.A2.SS1.p2.1.m1.1a"><mi id="Pt0.A2.SS1.p2.1.m1.1.1" xref="Pt0.A2.SS1.p2.1.m1.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="Pt0.A2.SS1.p2.1.m1.1b"><ci id="Pt0.A2.SS1.p2.1.m1.1.1.cmml" xref="Pt0.A2.SS1.p2.1.m1.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A2.SS1.p2.1.m1.1c">k</annotation><annotation encoding="application/x-llamapun" id="Pt0.A2.SS1.p2.1.m1.1d">italic_k</annotation></semantics></math>-mer cardinality of the reference texts is done using <math alttext="2^{20}=1048576" class="ltx_Math" display="inline" id="Pt0.A2.SS1.p2.2.m2.1"><semantics id="Pt0.A2.SS1.p2.2.m2.1a"><mrow id="Pt0.A2.SS1.p2.2.m2.1.1" xref="Pt0.A2.SS1.p2.2.m2.1.1.cmml"><msup id="Pt0.A2.SS1.p2.2.m2.1.1.2" xref="Pt0.A2.SS1.p2.2.m2.1.1.2.cmml"><mn id="Pt0.A2.SS1.p2.2.m2.1.1.2.2" xref="Pt0.A2.SS1.p2.2.m2.1.1.2.2.cmml">2</mn><mn id="Pt0.A2.SS1.p2.2.m2.1.1.2.3" xref="Pt0.A2.SS1.p2.2.m2.1.1.2.3.cmml">20</mn></msup><mo id="Pt0.A2.SS1.p2.2.m2.1.1.1" xref="Pt0.A2.SS1.p2.2.m2.1.1.1.cmml">=</mo><mn id="Pt0.A2.SS1.p2.2.m2.1.1.3" xref="Pt0.A2.SS1.p2.2.m2.1.1.3.cmml">1048576</mn></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A2.SS1.p2.2.m2.1b"><apply id="Pt0.A2.SS1.p2.2.m2.1.1.cmml" xref="Pt0.A2.SS1.p2.2.m2.1.1"><eq id="Pt0.A2.SS1.p2.2.m2.1.1.1.cmml" xref="Pt0.A2.SS1.p2.2.m2.1.1.1"></eq><apply id="Pt0.A2.SS1.p2.2.m2.1.1.2.cmml" xref="Pt0.A2.SS1.p2.2.m2.1.1.2"><csymbol cd="ambiguous" id="Pt0.A2.SS1.p2.2.m2.1.1.2.1.cmml" xref="Pt0.A2.SS1.p2.2.m2.1.1.2">superscript</csymbol><cn id="Pt0.A2.SS1.p2.2.m2.1.1.2.2.cmml" type="integer" xref="Pt0.A2.SS1.p2.2.m2.1.1.2.2">2</cn><cn id="Pt0.A2.SS1.p2.2.m2.1.1.2.3.cmml" type="integer" xref="Pt0.A2.SS1.p2.2.m2.1.1.2.3">20</cn></apply><cn id="Pt0.A2.SS1.p2.2.m2.1.1.3.cmml" type="integer" xref="Pt0.A2.SS1.p2.2.m2.1.1.3">1048576</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A2.SS1.p2.2.m2.1c">2^{20}=1048576</annotation><annotation encoding="application/x-llamapun" id="Pt0.A2.SS1.p2.2.m2.1d">2 start_POSTSUPERSCRIPT 20 end_POSTSUPERSCRIPT = 1048576</annotation></semantics></math> bytes for HyperLogLog registers. The desired false positive rate is set to <math alttext="\epsilon=1/10" class="ltx_Math" display="inline" id="Pt0.A2.SS1.p2.3.m3.1"><semantics id="Pt0.A2.SS1.p2.3.m3.1a"><mrow id="Pt0.A2.SS1.p2.3.m3.1.1" xref="Pt0.A2.SS1.p2.3.m3.1.1.cmml"><mi id="Pt0.A2.SS1.p2.3.m3.1.1.2" xref="Pt0.A2.SS1.p2.3.m3.1.1.2.cmml">ϵ</mi><mo id="Pt0.A2.SS1.p2.3.m3.1.1.1" xref="Pt0.A2.SS1.p2.3.m3.1.1.1.cmml">=</mo><mrow id="Pt0.A2.SS1.p2.3.m3.1.1.3" xref="Pt0.A2.SS1.p2.3.m3.1.1.3.cmml"><mn id="Pt0.A2.SS1.p2.3.m3.1.1.3.2" xref="Pt0.A2.SS1.p2.3.m3.1.1.3.2.cmml">1</mn><mo id="Pt0.A2.SS1.p2.3.m3.1.1.3.1" xref="Pt0.A2.SS1.p2.3.m3.1.1.3.1.cmml">/</mo><mn id="Pt0.A2.SS1.p2.3.m3.1.1.3.3" xref="Pt0.A2.SS1.p2.3.m3.1.1.3.3.cmml">10</mn></mrow></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A2.SS1.p2.3.m3.1b"><apply id="Pt0.A2.SS1.p2.3.m3.1.1.cmml" xref="Pt0.A2.SS1.p2.3.m3.1.1"><eq id="Pt0.A2.SS1.p2.3.m3.1.1.1.cmml" xref="Pt0.A2.SS1.p2.3.m3.1.1.1"></eq><ci id="Pt0.A2.SS1.p2.3.m3.1.1.2.cmml" xref="Pt0.A2.SS1.p2.3.m3.1.1.2">italic-ϵ</ci><apply id="Pt0.A2.SS1.p2.3.m3.1.1.3.cmml" xref="Pt0.A2.SS1.p2.3.m3.1.1.3"><divide id="Pt0.A2.SS1.p2.3.m3.1.1.3.1.cmml" xref="Pt0.A2.SS1.p2.3.m3.1.1.3.1"></divide><cn id="Pt0.A2.SS1.p2.3.m3.1.1.3.2.cmml" type="integer" xref="Pt0.A2.SS1.p2.3.m3.1.1.3.2">1</cn><cn id="Pt0.A2.SS1.p2.3.m3.1.1.3.3.cmml" type="integer" xref="Pt0.A2.SS1.p2.3.m3.1.1.3.3">10</cn></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A2.SS1.p2.3.m3.1c">\epsilon=1/10</annotation><annotation encoding="application/x-llamapun" id="Pt0.A2.SS1.p2.3.m3.1d">italic_ϵ = 1 / 10</annotation></semantics></math>. As mentioned in Section <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4" title="4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">4</span></a>, the Bloom filter is built for <math alttext="k=20" class="ltx_Math" display="inline" id="Pt0.A2.SS1.p2.4.m4.1"><semantics id="Pt0.A2.SS1.p2.4.m4.1a"><mrow id="Pt0.A2.SS1.p2.4.m4.1.1" xref="Pt0.A2.SS1.p2.4.m4.1.1.cmml"><mi id="Pt0.A2.SS1.p2.4.m4.1.1.2" xref="Pt0.A2.SS1.p2.4.m4.1.1.2.cmml">k</mi><mo id="Pt0.A2.SS1.p2.4.m4.1.1.1" xref="Pt0.A2.SS1.p2.4.m4.1.1.1.cmml">=</mo><mn id="Pt0.A2.SS1.p2.4.m4.1.1.3" xref="Pt0.A2.SS1.p2.4.m4.1.1.3.cmml">20</mn></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A2.SS1.p2.4.m4.1b"><apply id="Pt0.A2.SS1.p2.4.m4.1.1.cmml" xref="Pt0.A2.SS1.p2.4.m4.1.1"><eq id="Pt0.A2.SS1.p2.4.m4.1.1.1.cmml" xref="Pt0.A2.SS1.p2.4.m4.1.1.1"></eq><ci id="Pt0.A2.SS1.p2.4.m4.1.1.2.cmml" xref="Pt0.A2.SS1.p2.4.m4.1.1.2">𝑘</ci><cn id="Pt0.A2.SS1.p2.4.m4.1.1.3.cmml" type="integer" xref="Pt0.A2.SS1.p2.4.m4.1.1.3">20</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A2.SS1.p2.4.m4.1c">k=20</annotation><annotation encoding="application/x-llamapun" id="Pt0.A2.SS1.p2.4.m4.1d">italic_k = 20</annotation></semantics></math> and <math alttext="h=1" class="ltx_Math" display="inline" id="Pt0.A2.SS1.p2.5.m5.1"><semantics id="Pt0.A2.SS1.p2.5.m5.1a"><mrow id="Pt0.A2.SS1.p2.5.m5.1.1" xref="Pt0.A2.SS1.p2.5.m5.1.1.cmml"><mi id="Pt0.A2.SS1.p2.5.m5.1.1.2" xref="Pt0.A2.SS1.p2.5.m5.1.1.2.cmml">h</mi><mo id="Pt0.A2.SS1.p2.5.m5.1.1.1" xref="Pt0.A2.SS1.p2.5.m5.1.1.1.cmml">=</mo><mn id="Pt0.A2.SS1.p2.5.m5.1.1.3" xref="Pt0.A2.SS1.p2.5.m5.1.1.3.cmml">1</mn></mrow><annotation-xml encoding="MathML-Content" id="Pt0.A2.SS1.p2.5.m5.1b"><apply id="Pt0.A2.SS1.p2.5.m5.1.1.cmml" xref="Pt0.A2.SS1.p2.5.m5.1.1"><eq id="Pt0.A2.SS1.p2.5.m5.1.1.1.cmml" xref="Pt0.A2.SS1.p2.5.m5.1.1.1"></eq><ci id="Pt0.A2.SS1.p2.5.m5.1.1.2.cmml" xref="Pt0.A2.SS1.p2.5.m5.1.1.2">ℎ</ci><cn id="Pt0.A2.SS1.p2.5.m5.1.1.3.cmml" type="integer" xref="Pt0.A2.SS1.p2.5.m5.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A2.SS1.p2.5.m5.1c">h=1</annotation><annotation encoding="application/x-llamapun" id="Pt0.A2.SS1.p2.5.m5.1d">italic_h = 1</annotation></semantics></math> hash functions. The <span class="ltx_text ltx_font_typewriter" id="Pt0.A2.SS1.p2.5.1">kebab</span> build command corresponding to these parameters (using 16 threads) is</p>
<table class="ltx_equation ltx_eqn_table" id="Pt0.A2.Ex5">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_text ltx_markedasmath ltx_font_typewriter" id="Pt0.A2.Ex5.1">./kebab build -k 20 -e 0.1 -f 1 -t 16 [TEXT] -o [FILTER]</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p class="ltx_p" id="Pt0.A2.SS1.p2.6">with the corresponding query command (using <math alttext="L=40)" class="ltx_math_unparsed" display="inline" id="Pt0.A2.SS1.p2.6.m1.1"><semantics id="Pt0.A2.SS1.p2.6.m1.1a"><mrow id="Pt0.A2.SS1.p2.6.m1.1b"><mi id="Pt0.A2.SS1.p2.6.m1.1.1">L</mi><mo id="Pt0.A2.SS1.p2.6.m1.1.2">=</mo><mn id="Pt0.A2.SS1.p2.6.m1.1.3">40</mn><mo id="Pt0.A2.SS1.p2.6.m1.1.4" stretchy="false">)</mo></mrow><annotation encoding="application/x-tex" id="Pt0.A2.SS1.p2.6.m1.1c">L=40)</annotation><annotation encoding="application/x-llamapun" id="Pt0.A2.SS1.p2.6.m1.1d">italic_L = 40 )</annotation></semantics></math></p>
<table class="ltx_equation ltx_eqn_table" id="Pt0.A2.Ex6">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_text ltx_markedasmath ltx_font_typewriter" id="Pt0.A2.Ex6.1">./kebab scan -o [OUTPUT] -i [FILTER] -l 40 -t 16 [PATTERN]</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p class="ltx_p" id="Pt0.A2.SS1.p2.7">where <span class="ltx_text ltx_font_typewriter" id="Pt0.A2.SS1.p2.7.1">-s</span> is added to sort by length for top-<math alttext="t" class="ltx_Math" display="inline" id="Pt0.A2.SS1.p2.7.m1.1"><semantics id="Pt0.A2.SS1.p2.7.m1.1a"><mi id="Pt0.A2.SS1.p2.7.m1.1.1" xref="Pt0.A2.SS1.p2.7.m1.1.1.cmml">t</mi><annotation-xml encoding="MathML-Content" id="Pt0.A2.SS1.p2.7.m1.1b"><ci id="Pt0.A2.SS1.p2.7.m1.1.1.cmml" xref="Pt0.A2.SS1.p2.7.m1.1.1">𝑡</ci></annotation-xml><annotation encoding="application/x-tex" id="Pt0.A2.SS1.p2.7.m1.1c">t</annotation><annotation encoding="application/x-llamapun" id="Pt0.A2.SS1.p2.7.m1.1d">italic_t</annotation></semantics></math> modes. For <span class="ltx_text ltx_font_typewriter" id="Pt0.A2.SS1.p2.7.2">ropebwt3</span> and <span class="ltx_text ltx_font_typewriter" id="Pt0.A2.SS1.p2.7.3">tagger</span> we use default flags, passing only corresponding minimum-MEM length and thread parameters.</p>
</div>
</section>
<section class="ltx_subsection" id="Pt0.A2.SS2">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">0.B.2 </span>Output coordinates</h3>
<div class="ltx_para" id="Pt0.A2.SS2.p1">
<p class="ltx_p" id="Pt0.A2.SS2.p1.1">Passing pseudo-MEMs to <span class="ltx_text ltx_font_typewriter" id="Pt0.A2.SS2.p1.1.1">ropebwt3</span> results in a slight variation in the output coordinates, since it reports the positions of MEMs with respect to the given input pattern which are no longer full reads; however, pseudo-MEMs are output with <span class="ltx_text ltx_font_typewriter" id="Pt0.A2.SS2.p1.1.2">[SEQ]:[START]-[END]</span> identifiers to relate them back to their original pattern. Thus, a script can optionally be run to “fix” this output to exactly match that of running <span class="ltx_text ltx_font_typewriter" id="Pt0.A2.SS2.p1.1.3">ropebwt3</span> alone by reorienting pseudo-MEM coordinates back to full pattern coordinates. This does not change the actual MEMs found and they are still recoverable from the pseudo-MEM files, so we omit this step in Figures <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4.F2" title="Figure 2 ‣ 4.1 MEM-finding ‣ 4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">2</span></a> and <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4.F3" title="Figure 3 ‣ 4.1 MEM-finding ‣ 4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">3</span></a>. The run-time of just <span class="ltx_text ltx_font_typewriter" id="Pt0.A2.SS2.p1.1.4">kebab</span> (with data/parameters of Figure <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#S4.F2" title="Figure 2 ‣ 4.1 MEM-finding ‣ 4 Experiments ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">2</span></a> and corresponding settings from Section <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#Pt0.A2.SS1" title="0.B.1 Experiments ‣ Appendix 0.B Technical details ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">0.B.1</span></a>) compared to running our simple, single-threaded fix is shown in Figure <a class="ltx_ref" href="https://arxiv.org/html/2502.20338v3#Pt0.A2.F1" title="Figure A1 ‣ 0.B.2 Output coordinates ‣ Appendix 0.B Technical details ‣ KeBaB: 𝑘-mer based breaking for finding long MEMs"><span class="ltx_text ltx_ref_tag">A1</span></a>.</p>
</div>
<figure class="ltx_figure" id="Pt0.A2.F1"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="187" id="Pt0.A2.F1.g1" src="x6.png" width="747"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure A1: </span>Compares the time to “fix” the output of <span class="ltx_text ltx_font_typewriter" id="Pt0.A2.F1.5.1">ropebwt3</span> using pseudo-MEMs (to that of <span class="ltx_text ltx_font_typewriter" id="Pt0.A2.F1.6.2">ropebwt3</span> alone) against the <span class="ltx_text ltx_font_typewriter" id="Pt0.A2.F1.7.3">kebab</span> filter step. Where <span class="ltx_text ltx_font_typewriter" id="Pt0.A2.F1.8.4">kebab</span>’s speed depends only on the pattern lengths, fixing output depends on the number of distinct MEMs.</figcaption>
</figure>
</section>
</section>
</article>
</div>
<footer class="ltx_page_footer">
<div class="ltx_page_logo">Generated  on Mon Jun  9 16:47:56 2025 by <a class="ltx_LaTeXML_logo" href="http://dlmf.nist.gov/LaTeXML/"><span style="letter-spacing:-0.2em; margin-right:0.1em;">L<span class="ltx_font_smallcaps" style="position:relative; bottom:2.2pt;">a</span>T<span class="ltx_font_smallcaps" style="font-size:120%;position:relative; bottom:-0.2ex;">e</span></span><span style="font-size:90%; position:relative; bottom:-0.2ex;">XML</span><img alt="Mascot Sammy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg=="/></a>
</div></footer>
</div>
</body>
</html>
